/*

Copyright 2023 Keyfactor
Licensed under the Apache License, Version 2.0 (the License); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.

Keyfactor API Reference and Utility

<p>This page provides a utility through which the Keyfactor API endpoints can be called and results returned.                                                           It is intended to be used primarily for validation, testing and workflow development.                                                           It also serves secondarily as documentation for the API.</p>                                                          <p>If you would like to view documentation containing details on the Keyfactor API and endpoints,                                                           please refer to the Web API section of the Keyfactor Command documentation.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package command

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

// OrchestratorJobApiService OrchestratorJobApi service
type OrchestratorJobApiService service

type ApiOrchestratorJobsAcknowledgePostRequest struct {
	ctx                                                                 context.Context
	ApiService                                                          *OrchestratorJobApiService
	xKeyfactorRequestedWith                                             *string
	xKeyfactorApiVersion                                                *string
	keyfactorWebKeyfactorApiModelsOrchestratorJobsAcknowledgeJobRequest *KeyfactorWebKeyfactorApiModelsOrchestratorJobsAcknowledgeJobRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobsAcknowledgePostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobsAcknowledgePostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobsAcknowledgePostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobsAcknowledgePostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information to identify the jobs to acknowledge, either a query or a list of job identifiers
func (r ApiOrchestratorJobsAcknowledgePostRequest) KeyfactorWebKeyfactorApiModelsOrchestratorJobsAcknowledgeJobRequest(keyfactorWebKeyfactorApiModelsOrchestratorJobsAcknowledgeJobRequest KeyfactorWebKeyfactorApiModelsOrchestratorJobsAcknowledgeJobRequest) ApiOrchestratorJobsAcknowledgePostRequest {
	r.keyfactorWebKeyfactorApiModelsOrchestratorJobsAcknowledgeJobRequest = &keyfactorWebKeyfactorApiModelsOrchestratorJobsAcknowledgeJobRequest
	return r
}

func (r ApiOrchestratorJobsAcknowledgePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrchestratorJobsAcknowledgePostExecute(r)
}

/*
OrchestratorJobsAcknowledgePost Acknowledges orchestrator jobs based on the provided information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOrchestratorJobsAcknowledgePostRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobsAcknowledgePost(ctx context.Context) ApiOrchestratorJobsAcknowledgePostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiOrchestratorJobsAcknowledgePostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *OrchestratorJobApiService) OrchestratorJobsAcknowledgePostExecute(r ApiOrchestratorJobsAcknowledgePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/OrchestratorJobs/Acknowledge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsOrchestratorJobsAcknowledgeJobRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrchestratorJobsCustomBulkPostRequest struct {
	ctx                                          context.Context
	ApiService                                   *OrchestratorJobApiService
	xKeyfactorRequestedWith                      *string
	xKeyfactorApiVersion                         *string
	modelsOrchestratorJobsScheduleBulkJobRequest *ModelsOrchestratorJobsScheduleBulkJobRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobsCustomBulkPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobsCustomBulkPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobsCustomBulkPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobsCustomBulkPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information to use to schedule the jobs, including the type of custom job, agents to use, and job-specific parameters.
func (r ApiOrchestratorJobsCustomBulkPostRequest) ModelsOrchestratorJobsScheduleBulkJobRequest(modelsOrchestratorJobsScheduleBulkJobRequest ModelsOrchestratorJobsScheduleBulkJobRequest) ApiOrchestratorJobsCustomBulkPostRequest {
	r.modelsOrchestratorJobsScheduleBulkJobRequest = &modelsOrchestratorJobsScheduleBulkJobRequest
	return r
}

func (r ApiOrchestratorJobsCustomBulkPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsOrchestratorJobsBulkJobResponse, *http.Response, error) {
	return r.ApiService.OrchestratorJobsCustomBulkPostExecute(r)
}

/*
OrchestratorJobsCustomBulkPost Schedules the same job for a custom JobType on the specified agents using the provided information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOrchestratorJobsCustomBulkPostRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobsCustomBulkPost(ctx context.Context) ApiOrchestratorJobsCustomBulkPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiOrchestratorJobsCustomBulkPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsOrchestratorJobsBulkJobResponse
func (a *OrchestratorJobApiService) OrchestratorJobsCustomBulkPostExecute(r ApiOrchestratorJobsCustomBulkPostRequest) (*KeyfactorWebKeyfactorApiModelsOrchestratorJobsBulkJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsOrchestratorJobsBulkJobResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/OrchestratorJobs/Custom/Bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.modelsOrchestratorJobsScheduleBulkJobRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrchestratorJobsCustomPostRequest struct {
	ctx                                      context.Context
	ApiService                               *OrchestratorJobApiService
	xKeyfactorRequestedWith                  *string
	xKeyfactorApiVersion                     *string
	modelsOrchestratorJobsScheduleJobRequest *ModelsOrchestratorJobsScheduleJobRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobsCustomPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobsCustomPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobsCustomPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobsCustomPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information to use to schedule the job, including the type of custom job, agent to use, and job-specific parameters.
func (r ApiOrchestratorJobsCustomPostRequest) ModelsOrchestratorJobsScheduleJobRequest(modelsOrchestratorJobsScheduleJobRequest ModelsOrchestratorJobsScheduleJobRequest) ApiOrchestratorJobsCustomPostRequest {
	r.modelsOrchestratorJobsScheduleJobRequest = &modelsOrchestratorJobsScheduleJobRequest
	return r
}

func (r ApiOrchestratorJobsCustomPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsOrchestratorJobsJobResponse, *http.Response, error) {
	return r.ApiService.OrchestratorJobsCustomPostExecute(r)
}

/*
OrchestratorJobsCustomPost Schedules a job for a custom JobType on the agent using the provided information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOrchestratorJobsCustomPostRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobsCustomPost(ctx context.Context) ApiOrchestratorJobsCustomPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiOrchestratorJobsCustomPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsOrchestratorJobsJobResponse
func (a *OrchestratorJobApiService) OrchestratorJobsCustomPostExecute(r ApiOrchestratorJobsCustomPostRequest) (*KeyfactorWebKeyfactorApiModelsOrchestratorJobsJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsOrchestratorJobsJobResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/OrchestratorJobs/Custom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.modelsOrchestratorJobsScheduleJobRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrchestratorJobsJobHistoryGetRequest struct {
	ctx                     context.Context
	ApiService              *OrchestratorJobApiService
	xKeyfactorRequestedWith *string
	queryString             *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobsJobHistoryGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobsJobHistoryGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiOrchestratorJobsJobHistoryGetRequest) QueryString(queryString string) ApiOrchestratorJobsJobHistoryGetRequest {
	r.queryString = &queryString
	return r
}

func (r ApiOrchestratorJobsJobHistoryGetRequest) PageReturned(pageReturned int32) ApiOrchestratorJobsJobHistoryGetRequest {
	r.pageReturned = &pageReturned
	return r
}

func (r ApiOrchestratorJobsJobHistoryGetRequest) ReturnLimit(returnLimit int32) ApiOrchestratorJobsJobHistoryGetRequest {
	r.returnLimit = &returnLimit
	return r
}

func (r ApiOrchestratorJobsJobHistoryGetRequest) SortField(sortField string) ApiOrchestratorJobsJobHistoryGetRequest {
	r.sortField = &sortField
	return r
}

func (r ApiOrchestratorJobsJobHistoryGetRequest) SortAscending(sortAscending int32) ApiOrchestratorJobsJobHistoryGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobsJobHistoryGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobsJobHistoryGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiOrchestratorJobsJobHistoryGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsCertificateStoresJobHistoryResponse, *http.Response, error) {
	return r.ApiService.OrchestratorJobsJobHistoryGetExecute(r)
}

/*
OrchestratorJobsJobHistoryGet Returns all histories of an orchestrator job according to the provided filter and output parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOrchestratorJobsJobHistoryGetRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobsJobHistoryGet(ctx context.Context) ApiOrchestratorJobsJobHistoryGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiOrchestratorJobsJobHistoryGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsCertificateStoresJobHistoryResponse
func (a *OrchestratorJobApiService) OrchestratorJobsJobHistoryGetExecute(r ApiOrchestratorJobsJobHistoryGetRequest) ([]KeyfactorWebKeyfactorApiModelsCertificateStoresJobHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsCertificateStoresJobHistoryResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/OrchestratorJobs/JobHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.queryString != nil {
		parameterAddToQuery(localVarQueryParams, "QueryString", r.queryString, "")
	}
	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrchestratorJobsJobStatusDataGetRequest struct {
	ctx                     context.Context
	ApiService              *OrchestratorJobApiService
	jobHistoryId            *int64
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Identifier of the job history record to retrieve
func (r ApiOrchestratorJobsJobStatusDataGetRequest) JobHistoryId(jobHistoryId int64) ApiOrchestratorJobsJobStatusDataGetRequest {
	r.jobHistoryId = &jobHistoryId
	return r
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobsJobStatusDataGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobsJobStatusDataGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobsJobStatusDataGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobsJobStatusDataGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiOrchestratorJobsJobStatusDataGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsOrchestratorJobsCustomJobResultDataResponse, *http.Response, error) {
	return r.ApiService.OrchestratorJobsJobStatusDataGetExecute(r)
}

/*
OrchestratorJobsJobStatusDataGet Retrieves the results of a custom job using the provided information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOrchestratorJobsJobStatusDataGetRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobsJobStatusDataGet(ctx context.Context) ApiOrchestratorJobsJobStatusDataGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiOrchestratorJobsJobStatusDataGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsOrchestratorJobsCustomJobResultDataResponse
func (a *OrchestratorJobApiService) OrchestratorJobsJobStatusDataGetExecute(r ApiOrchestratorJobsJobStatusDataGetRequest) (*KeyfactorWebKeyfactorApiModelsOrchestratorJobsCustomJobResultDataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsOrchestratorJobsCustomJobResultDataResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/OrchestratorJobs/JobStatus/Data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobHistoryId == nil {
		return localVarReturnValue, nil, reportError("jobHistoryId is required and must be specified")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "jobHistoryId", r.jobHistoryId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrchestratorJobsReschedulePostRequest struct {
	ctx                                                                context.Context
	ApiService                                                         *OrchestratorJobApiService
	xKeyfactorRequestedWith                                            *string
	xKeyfactorApiVersion                                               *string
	keyfactorWebKeyfactorApiModelsOrchestratorJobsRescheduleJobRequest *KeyfactorWebKeyfactorApiModelsOrchestratorJobsRescheduleJobRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobsReschedulePostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobsReschedulePostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobsReschedulePostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobsReschedulePostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information to identify the jobs to reschedule, either a query or a list of job identifiers
func (r ApiOrchestratorJobsReschedulePostRequest) KeyfactorWebKeyfactorApiModelsOrchestratorJobsRescheduleJobRequest(keyfactorWebKeyfactorApiModelsOrchestratorJobsRescheduleJobRequest KeyfactorWebKeyfactorApiModelsOrchestratorJobsRescheduleJobRequest) ApiOrchestratorJobsReschedulePostRequest {
	r.keyfactorWebKeyfactorApiModelsOrchestratorJobsRescheduleJobRequest = &keyfactorWebKeyfactorApiModelsOrchestratorJobsRescheduleJobRequest
	return r
}

func (r ApiOrchestratorJobsReschedulePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrchestratorJobsReschedulePostExecute(r)
}

/*
OrchestratorJobsReschedulePost Reschedules orchestrator jobs based on the provided information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOrchestratorJobsReschedulePostRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobsReschedulePost(ctx context.Context) ApiOrchestratorJobsReschedulePostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiOrchestratorJobsReschedulePostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *OrchestratorJobApiService) OrchestratorJobsReschedulePostExecute(r ApiOrchestratorJobsReschedulePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/OrchestratorJobs/Reschedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsOrchestratorJobsRescheduleJobRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOrchestratorJobsScheduledJobsGetRequest struct {
	ctx                     context.Context
	ApiService              *OrchestratorJobApiService
	xKeyfactorRequestedWith *string
	queryString             *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobsScheduledJobsGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobsScheduledJobsGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiOrchestratorJobsScheduledJobsGetRequest) QueryString(queryString string) ApiOrchestratorJobsScheduledJobsGetRequest {
	r.queryString = &queryString
	return r
}

func (r ApiOrchestratorJobsScheduledJobsGetRequest) PageReturned(pageReturned int32) ApiOrchestratorJobsScheduledJobsGetRequest {
	r.pageReturned = &pageReturned
	return r
}

func (r ApiOrchestratorJobsScheduledJobsGetRequest) ReturnLimit(returnLimit int32) ApiOrchestratorJobsScheduledJobsGetRequest {
	r.returnLimit = &returnLimit
	return r
}

func (r ApiOrchestratorJobsScheduledJobsGetRequest) SortField(sortField string) ApiOrchestratorJobsScheduledJobsGetRequest {
	r.sortField = &sortField
	return r
}

func (r ApiOrchestratorJobsScheduledJobsGetRequest) SortAscending(sortAscending int32) ApiOrchestratorJobsScheduledJobsGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobsScheduledJobsGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobsScheduledJobsGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiOrchestratorJobsScheduledJobsGetRequest) Execute() ([]ModelsOrchestratorJobsJob, *http.Response, error) {
	return r.ApiService.OrchestratorJobsScheduledJobsGetExecute(r)
}

/*
OrchestratorJobsScheduledJobsGet Returns all scheduled orchestrator jobs according to the provided filter and output parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOrchestratorJobsScheduledJobsGetRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobsScheduledJobsGet(ctx context.Context) ApiOrchestratorJobsScheduledJobsGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiOrchestratorJobsScheduledJobsGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []ModelsOrchestratorJobsJob
func (a *OrchestratorJobApiService) OrchestratorJobsScheduledJobsGetExecute(r ApiOrchestratorJobsScheduledJobsGetRequest) ([]ModelsOrchestratorJobsJob, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ModelsOrchestratorJobsJob
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/OrchestratorJobs/ScheduledJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.queryString != nil {
		parameterAddToQuery(localVarQueryParams, "QueryString", r.queryString, "")
	}
	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrchestratorJobsUnschedulePostRequest struct {
	ctx                                                                context.Context
	ApiService                                                         *OrchestratorJobApiService
	xKeyfactorRequestedWith                                            *string
	xKeyfactorApiVersion                                               *string
	keyfactorWebKeyfactorApiModelsOrchestratorJobsUnscheduleJobRequest *KeyfactorWebKeyfactorApiModelsOrchestratorJobsUnscheduleJobRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiOrchestratorJobsUnschedulePostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiOrchestratorJobsUnschedulePostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiOrchestratorJobsUnschedulePostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiOrchestratorJobsUnschedulePostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information to identify the orchestrator jobs to unschedule, either a query or a list of job identifiers
func (r ApiOrchestratorJobsUnschedulePostRequest) KeyfactorWebKeyfactorApiModelsOrchestratorJobsUnscheduleJobRequest(keyfactorWebKeyfactorApiModelsOrchestratorJobsUnscheduleJobRequest KeyfactorWebKeyfactorApiModelsOrchestratorJobsUnscheduleJobRequest) ApiOrchestratorJobsUnschedulePostRequest {
	r.keyfactorWebKeyfactorApiModelsOrchestratorJobsUnscheduleJobRequest = &keyfactorWebKeyfactorApiModelsOrchestratorJobsUnscheduleJobRequest
	return r
}

func (r ApiOrchestratorJobsUnschedulePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrchestratorJobsUnschedulePostExecute(r)
}

/*
OrchestratorJobsUnschedulePost Unschedules orchestrator jobs based on the provided information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiOrchestratorJobsUnschedulePostRequest
*/
func (a *OrchestratorJobApiService) OrchestratorJobsUnschedulePost(ctx context.Context) ApiOrchestratorJobsUnschedulePostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiOrchestratorJobsUnschedulePostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *OrchestratorJobApiService) OrchestratorJobsUnschedulePostExecute(r ApiOrchestratorJobsUnschedulePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/OrchestratorJobs/Unschedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsOrchestratorJobsUnscheduleJobRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
