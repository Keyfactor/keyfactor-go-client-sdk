/*

Copyright 2023 Keyfactor
Licensed under the Apache License, Version 2.0 (the License); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.

Keyfactor API Reference and Utility

<p>This page provides a utility through which the Keyfactor API endpoints can be called and results returned.                                                           It is intended to be used primarily for validation, testing and workflow development.                                                           It also serves secondarily as documentation for the API.</p>                                                          <p>If you would like to view documentation containing details on the Keyfactor API and endpoints,                                                           please refer to the Web API section of the Keyfactor Command documentation.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package command

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// PAMProviderApiService PAMProviderApi service
type PAMProviderApiService service

type ApiPamProvidersGetRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	xKeyfactorRequestedWith *string
	queryString             *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPamProvidersGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPamProvidersGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiPamProvidersGetRequest) QueryString(queryString string) ApiPamProvidersGetRequest {
	r.queryString = &queryString
	return r
}

// The current page within the result set to be returned
func (r ApiPamProvidersGetRequest) PageReturned(pageReturned int32) ApiPamProvidersGetRequest {
	r.pageReturned = &pageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiPamProvidersGetRequest) ReturnLimit(returnLimit int32) ApiPamProvidersGetRequest {
	r.returnLimit = &returnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiPamProvidersGetRequest) SortField(sortField string) ApiPamProvidersGetRequest {
	r.sortField = &sortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiPamProvidersGetRequest) SortAscending(sortAscending int32) ApiPamProvidersGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPamProvidersGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPamProvidersGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiPamProvidersGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy, *http.Response, error) {
	return r.ApiService.PamProvidersGetExecute(r)
}

/*
PamProvidersGet Returns all PAM providers according to the provided filter and output parameters

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPamProvidersGetRequest
*/
func (a *PAMProviderApiService) PamProvidersGet(ctx context.Context) ApiPamProvidersGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiPamProvidersGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy
func (a *PAMProviderApiService) PamProvidersGetExecute(r ApiPamProvidersGetRequest) ([]KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/PamProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.queryString != nil {
		parameterAddToQuery(localVarQueryParams, "QueryString", r.queryString, "")
	}
	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPamProvidersIdDeleteRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPamProvidersIdDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPamProvidersIdDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPamProvidersIdDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPamProvidersIdDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiPamProvidersIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PamProvidersIdDeleteExecute(r)
}

/*
PamProvidersIdDelete Deletes a PAM Provider

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor identifier of the PAM provider to be deleted
	@return ApiPamProvidersIdDeleteRequest
*/
func (a *PAMProviderApiService) PamProvidersIdDelete(ctx context.Context, id int32) ApiPamProvidersIdDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiPamProvidersIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
func (a *PAMProviderApiService) PamProvidersIdDeleteExecute(r ApiPamProvidersIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/PamProviders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPamProvidersIdGetRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPamProvidersIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPamProvidersIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPamProvidersIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPamProvidersIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiPamProvidersIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy, *http.Response, error) {
	return r.ApiService.PamProvidersIdGetExecute(r)
}

/*
PamProvidersIdGet Returns a single PAM Provider that matches the associated id

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor identifier of the PAM provider
	@return ApiPamProvidersIdGetRequest
*/
func (a *PAMProviderApiService) PamProvidersIdGet(ctx context.Context, id int32) ApiPamProvidersIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiPamProvidersIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy
func (a *PAMProviderApiService) PamProvidersIdGetExecute(r ApiPamProvidersIdGetRequest) (*KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/PamProviders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 0 {
		return localVarReturnValue, nil, reportError("id must be greater than 0")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPamProvidersPostRequest struct {
	ctx                                                    context.Context
	ApiService                                             *PAMProviderApiService
	xKeyfactorRequestedWith                                *string
	xKeyfactorApiVersion                                   *string
	keyfactorWebKeyfactorApiModelsPAMProviderCreateRequest *KeyfactorWebKeyfactorApiModelsPAMProviderCreateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPamProvidersPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPamProvidersPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPamProvidersPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPamProvidersPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// PAM provider properties to be used
func (r ApiPamProvidersPostRequest) KeyfactorWebKeyfactorApiModelsPAMProviderCreateRequest(keyfactorWebKeyfactorApiModelsPAMProviderCreateRequest KeyfactorWebKeyfactorApiModelsPAMProviderCreateRequest) ApiPamProvidersPostRequest {
	r.keyfactorWebKeyfactorApiModelsPAMProviderCreateRequest = &keyfactorWebKeyfactorApiModelsPAMProviderCreateRequest
	return r
}

func (r ApiPamProvidersPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy, *http.Response, error) {
	return r.ApiService.PamProvidersPostExecute(r)
}

/*
PamProvidersPost Creates a new PAM provider with the associated properties

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPamProvidersPostRequest
*/
func (a *PAMProviderApiService) PamProvidersPost(ctx context.Context) ApiPamProvidersPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiPamProvidersPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy
func (a *PAMProviderApiService) PamProvidersPostExecute(r ApiPamProvidersPostRequest) (*KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/PamProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsPAMProviderCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPamProvidersPutRequest struct {
	ctx                                                          context.Context
	ApiService                                                   *PAMProviderApiService
	xKeyfactorRequestedWith                                      *string
	xKeyfactorApiVersion                                         *string
	keyfactorWebKeyfactorApiModelsPAMProviderUpdateRequestLegacy *KeyfactorWebKeyfactorApiModelsPAMProviderUpdateRequestLegacy
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPamProvidersPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPamProvidersPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPamProvidersPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPamProvidersPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// PAM provider properties to be used
func (r ApiPamProvidersPutRequest) KeyfactorWebKeyfactorApiModelsPAMProviderUpdateRequestLegacy(keyfactorWebKeyfactorApiModelsPAMProviderUpdateRequestLegacy KeyfactorWebKeyfactorApiModelsPAMProviderUpdateRequestLegacy) ApiPamProvidersPutRequest {
	r.keyfactorWebKeyfactorApiModelsPAMProviderUpdateRequestLegacy = &keyfactorWebKeyfactorApiModelsPAMProviderUpdateRequestLegacy
	return r
}

func (r ApiPamProvidersPutRequest) Execute() (*KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy, *http.Response, error) {
	return r.ApiService.PamProvidersPutExecute(r)
}

/*
PamProvidersPut Updates an existing PAM provider according to the provided properties

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPamProvidersPutRequest
*/
func (a *PAMProviderApiService) PamProvidersPut(ctx context.Context) ApiPamProvidersPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiPamProvidersPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy
func (a *PAMProviderApiService) PamProvidersPutExecute(r ApiPamProvidersPutRequest) (*KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsPAMProviderResponseLegacy
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/PamProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsPAMProviderUpdateRequestLegacy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPamProvidersTypesGetRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPamProvidersTypesGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPamProvidersTypesGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPamProvidersTypesGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPamProvidersTypesGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiPamProvidersTypesGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsPAMProviderTypeResponse, *http.Response, error) {
	return r.ApiService.PamProvidersTypesGetExecute(r)
}

/*
PamProvidersTypesGet Returns all PAM providers in the Keyfactor instance

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPamProvidersTypesGetRequest
*/
func (a *PAMProviderApiService) PamProvidersTypesGet(ctx context.Context) ApiPamProvidersTypesGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiPamProvidersTypesGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsPAMProviderTypeResponse
func (a *PAMProviderApiService) PamProvidersTypesGetExecute(r ApiPamProvidersTypesGetRequest) ([]KeyfactorWebKeyfactorApiModelsPAMProviderTypeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsPAMProviderTypeResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/PamProviders/Types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPamProvidersTypesPostRequest struct {
	ctx                                                        context.Context
	ApiService                                                 *PAMProviderApiService
	xKeyfactorRequestedWith                                    *string
	xKeyfactorApiVersion                                       *string
	keyfactorWebKeyfactorApiModelsPAMProviderTypeCreateRequest *KeyfactorWebKeyfactorApiModelsPAMProviderTypeCreateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPamProvidersTypesPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPamProvidersTypesPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPamProvidersTypesPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPamProvidersTypesPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// PAM provider type properties to be used
func (r ApiPamProvidersTypesPostRequest) KeyfactorWebKeyfactorApiModelsPAMProviderTypeCreateRequest(keyfactorWebKeyfactorApiModelsPAMProviderTypeCreateRequest KeyfactorWebKeyfactorApiModelsPAMProviderTypeCreateRequest) ApiPamProvidersTypesPostRequest {
	r.keyfactorWebKeyfactorApiModelsPAMProviderTypeCreateRequest = &keyfactorWebKeyfactorApiModelsPAMProviderTypeCreateRequest
	return r
}

func (r ApiPamProvidersTypesPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsPAMProviderTypeResponse, *http.Response, error) {
	return r.ApiService.PamProvidersTypesPostExecute(r)
}

/*
PamProvidersTypesPost Creates a new PAM provider type with the associated properties

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPamProvidersTypesPostRequest
*/
func (a *PAMProviderApiService) PamProvidersTypesPost(ctx context.Context) ApiPamProvidersTypesPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiPamProvidersTypesPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsPAMProviderTypeResponse
func (a *PAMProviderApiService) PamProvidersTypesPostExecute(r ApiPamProvidersTypesPostRequest) (*KeyfactorWebKeyfactorApiModelsPAMProviderTypeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsPAMProviderTypeResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/PamProviders/Types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsPAMProviderTypeCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
