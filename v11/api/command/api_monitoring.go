/*

Copyright 2023 Keyfactor
Licensed under the Apache License, Version 2.0 (the License); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.

Keyfactor API Reference and Utility

<p>This page provides a utility through which the Keyfactor API endpoints can be called and results returned.                                                           It is intended to be used primarily for validation, testing and workflow development.                                                           It also serves secondarily as documentation for the API.</p>                                                          <p>If you would like to view documentation containing details on the Keyfactor API and endpoints,                                                           please refer to the Web API section of the Keyfactor Command documentation.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package command

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// MonitoringApiService MonitoringApi service
type MonitoringApiService service

type ApiMonitoringResolveOCSPPostRequest struct {
	ctx                                                           context.Context
	ApiService                                                    *MonitoringApiService
	xKeyfactorRequestedWith                                       *string
	xKeyfactorApiVersion                                          *string
	keyfactorWebKeyfactorApiModelsMonitoringOCSPParametersRequest *KeyfactorWebKeyfactorApiModelsMonitoringOCSPParametersRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiMonitoringResolveOCSPPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiMonitoringResolveOCSPPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiMonitoringResolveOCSPPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiMonitoringResolveOCSPPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information for the new endpoint
func (r ApiMonitoringResolveOCSPPostRequest) KeyfactorWebKeyfactorApiModelsMonitoringOCSPParametersRequest(keyfactorWebKeyfactorApiModelsMonitoringOCSPParametersRequest KeyfactorWebKeyfactorApiModelsMonitoringOCSPParametersRequest) ApiMonitoringResolveOCSPPostRequest {
	r.keyfactorWebKeyfactorApiModelsMonitoringOCSPParametersRequest = &keyfactorWebKeyfactorApiModelsMonitoringOCSPParametersRequest
	return r
}

func (r ApiMonitoringResolveOCSPPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsMonitoringOCSPParametersResponse, *http.Response, error) {
	return r.ApiService.MonitoringResolveOCSPPostExecute(r)
}

/*
MonitoringResolveOCSPPost Resolve the Certificate authority given

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMonitoringResolveOCSPPostRequest
*/
func (a *MonitoringApiService) MonitoringResolveOCSPPost(ctx context.Context) ApiMonitoringResolveOCSPPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiMonitoringResolveOCSPPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsMonitoringOCSPParametersResponse
func (a *MonitoringApiService) MonitoringResolveOCSPPostExecute(r ApiMonitoringResolveOCSPPostRequest) (*KeyfactorWebKeyfactorApiModelsMonitoringOCSPParametersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsMonitoringOCSPParametersResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Monitoring/ResolveOCSP"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsMonitoringOCSPParametersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitoringRevocationGetRequest struct {
	ctx                     context.Context
	ApiService              *MonitoringApiService
	xKeyfactorRequestedWith *string
	queryString             *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiMonitoringRevocationGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiMonitoringRevocationGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiMonitoringRevocationGetRequest) QueryString(queryString string) ApiMonitoringRevocationGetRequest {
	r.queryString = &queryString
	return r
}

func (r ApiMonitoringRevocationGetRequest) PageReturned(pageReturned int32) ApiMonitoringRevocationGetRequest {
	r.pageReturned = &pageReturned
	return r
}

func (r ApiMonitoringRevocationGetRequest) ReturnLimit(returnLimit int32) ApiMonitoringRevocationGetRequest {
	r.returnLimit = &returnLimit
	return r
}

func (r ApiMonitoringRevocationGetRequest) SortField(sortField string) ApiMonitoringRevocationGetRequest {
	r.sortField = &sortField
	return r
}

func (r ApiMonitoringRevocationGetRequest) SortAscending(sortAscending int32) ApiMonitoringRevocationGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiMonitoringRevocationGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiMonitoringRevocationGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiMonitoringRevocationGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse, *http.Response, error) {
	return r.ApiService.MonitoringRevocationGetExecute(r)
}

/*
MonitoringRevocationGet Gets all revocation monitoring endpoints according to the provided filter and output parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMonitoringRevocationGetRequest
*/
func (a *MonitoringApiService) MonitoringRevocationGet(ctx context.Context) ApiMonitoringRevocationGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiMonitoringRevocationGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse
func (a *MonitoringApiService) MonitoringRevocationGetExecute(r ApiMonitoringRevocationGetRequest) ([]KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Monitoring/Revocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.queryString != nil {
		parameterAddToQuery(localVarQueryParams, "QueryString", r.queryString, "")
	}
	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitoringRevocationIdDeleteRequest struct {
	ctx                     context.Context
	ApiService              *MonitoringApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiMonitoringRevocationIdDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiMonitoringRevocationIdDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiMonitoringRevocationIdDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiMonitoringRevocationIdDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiMonitoringRevocationIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.MonitoringRevocationIdDeleteExecute(r)
}

/*
MonitoringRevocationIdDelete Delete a revocation monitoring endpoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id for the revocation monitoring endpoint
	@return ApiMonitoringRevocationIdDeleteRequest
*/
func (a *MonitoringApiService) MonitoringRevocationIdDelete(ctx context.Context, id int32) ApiMonitoringRevocationIdDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiMonitoringRevocationIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
func (a *MonitoringApiService) MonitoringRevocationIdDeleteExecute(r ApiMonitoringRevocationIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Monitoring/Revocation/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMonitoringRevocationIdGetRequest struct {
	ctx                     context.Context
	ApiService              *MonitoringApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiMonitoringRevocationIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiMonitoringRevocationIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiMonitoringRevocationIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiMonitoringRevocationIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiMonitoringRevocationIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse, *http.Response, error) {
	return r.ApiService.MonitoringRevocationIdGetExecute(r)
}

/*
MonitoringRevocationIdGet Get a revocation monitoring endpoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id for the endpoint to get
	@return ApiMonitoringRevocationIdGetRequest
*/
func (a *MonitoringApiService) MonitoringRevocationIdGet(ctx context.Context, id int32) ApiMonitoringRevocationIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiMonitoringRevocationIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse
func (a *MonitoringApiService) MonitoringRevocationIdGetExecute(r ApiMonitoringRevocationIdGetRequest) (*KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Monitoring/Revocation/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitoringRevocationPostRequest struct {
	ctx                                                                         context.Context
	ApiService                                                                  *MonitoringApiService
	xKeyfactorRequestedWith                                                     *string
	xKeyfactorApiVersion                                                        *string
	keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringCreationRequest *KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringCreationRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiMonitoringRevocationPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiMonitoringRevocationPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiMonitoringRevocationPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiMonitoringRevocationPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information for the new endpoint
func (r ApiMonitoringRevocationPostRequest) KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringCreationRequest(keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringCreationRequest KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringCreationRequest) ApiMonitoringRevocationPostRequest {
	r.keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringCreationRequest = &keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringCreationRequest
	return r
}

func (r ApiMonitoringRevocationPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse, *http.Response, error) {
	return r.ApiService.MonitoringRevocationPostExecute(r)
}

/*
MonitoringRevocationPost Add a revocation monitoring endpoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMonitoringRevocationPostRequest
*/
func (a *MonitoringApiService) MonitoringRevocationPost(ctx context.Context) ApiMonitoringRevocationPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiMonitoringRevocationPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse
func (a *MonitoringApiService) MonitoringRevocationPostExecute(r ApiMonitoringRevocationPostRequest) (*KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Monitoring/Revocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringCreationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitoringRevocationPutRequest struct {
	ctx                                                                       context.Context
	ApiService                                                                *MonitoringApiService
	xKeyfactorRequestedWith                                                   *string
	xKeyfactorApiVersion                                                      *string
	keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringUpdateRequest *KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringUpdateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiMonitoringRevocationPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiMonitoringRevocationPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiMonitoringRevocationPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiMonitoringRevocationPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information for the endpoint
func (r ApiMonitoringRevocationPutRequest) KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringUpdateRequest(keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringUpdateRequest KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringUpdateRequest) ApiMonitoringRevocationPutRequest {
	r.keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringUpdateRequest = &keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringUpdateRequest
	return r
}

func (r ApiMonitoringRevocationPutRequest) Execute() (*KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse, *http.Response, error) {
	return r.ApiService.MonitoringRevocationPutExecute(r)
}

/*
MonitoringRevocationPut Edit a revocation monitoring endpoint

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMonitoringRevocationPutRequest
*/
func (a *MonitoringApiService) MonitoringRevocationPut(ctx context.Context) ApiMonitoringRevocationPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiMonitoringRevocationPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse
func (a *MonitoringApiService) MonitoringRevocationPutExecute(r ApiMonitoringRevocationPutRequest) (*KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringDefinitionResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Monitoring/Revocation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitoringRevocationTestAllPostRequest struct {
	ctx                                                                             context.Context
	ApiService                                                                      *MonitoringApiService
	xKeyfactorRequestedWith                                                         *string
	xKeyfactorApiVersion                                                            *string
	keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestAllRequest *KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestAllRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiMonitoringRevocationTestAllPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiMonitoringRevocationTestAllPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiMonitoringRevocationTestAllPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiMonitoringRevocationTestAllPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information about the revocation monitoring alert test
func (r ApiMonitoringRevocationTestAllPostRequest) KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestAllRequest(keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestAllRequest KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestAllRequest) ApiMonitoringRevocationTestAllPostRequest {
	r.keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestAllRequest = &keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestAllRequest
	return r
}

func (r ApiMonitoringRevocationTestAllPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestResponse, *http.Response, error) {
	return r.ApiService.MonitoringRevocationTestAllPostExecute(r)
}

/*
MonitoringRevocationTestAllPost Test All Alerts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMonitoringRevocationTestAllPostRequest
*/
func (a *MonitoringApiService) MonitoringRevocationTestAllPost(ctx context.Context) ApiMonitoringRevocationTestAllPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiMonitoringRevocationTestAllPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestResponse
func (a *MonitoringApiService) MonitoringRevocationTestAllPostExecute(r ApiMonitoringRevocationTestAllPostRequest) (*KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Monitoring/Revocation/TestAll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestAllRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitoringRevocationTestPostRequest struct {
	ctx                                                                          context.Context
	ApiService                                                                   *MonitoringApiService
	xKeyfactorRequestedWith                                                      *string
	xKeyfactorApiVersion                                                         *string
	keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestRequest *KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiMonitoringRevocationTestPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiMonitoringRevocationTestPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiMonitoringRevocationTestPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiMonitoringRevocationTestPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information about the revocation monitoring alert test
func (r ApiMonitoringRevocationTestPostRequest) KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestRequest(keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestRequest KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestRequest) ApiMonitoringRevocationTestPostRequest {
	r.keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestRequest = &keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestRequest
	return r
}

func (r ApiMonitoringRevocationTestPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestResponse, *http.Response, error) {
	return r.ApiService.MonitoringRevocationTestPostExecute(r)
}

/*
MonitoringRevocationTestPost Test Alert

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMonitoringRevocationTestPostRequest
*/
func (a *MonitoringApiService) MonitoringRevocationTestPost(ctx context.Context) ApiMonitoringRevocationTestPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiMonitoringRevocationTestPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestResponse
func (a *MonitoringApiService) MonitoringRevocationTestPostExecute(r ApiMonitoringRevocationTestPostRequest) (*KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Monitoring/Revocation/Test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsMonitoringRevocationMonitoringAlertTestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
