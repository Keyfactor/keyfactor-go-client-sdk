/*

Copyright 2023 Keyfactor
Licensed under the Apache License, Version 2.0 (the License); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.

Keyfactor API Reference and Utility

<p>This page provides a utility through which the Keyfactor API endpoints can be called and results returned.                                                           It is intended to be used primarily for validation, testing and workflow development.                                                           It also serves secondarily as documentation for the API.</p>                                                          <p>If you would like to view documentation containing details on the Keyfactor API and endpoints,                                                           please refer to the Web API section of the Keyfactor Command documentation.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package command

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// EnrollmentApiService EnrollmentApi service
type EnrollmentApiService service

type ApiEnrollmentAvailableRenewalIdIdGetRequest struct {
	ctx                     context.Context
	ApiService              *EnrollmentApiService
	id                      int32
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentAvailableRenewalIdIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentAvailableRenewalIdIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The collection id for the given certificate
func (r ApiEnrollmentAvailableRenewalIdIdGetRequest) CollectionId(collectionId int32) ApiEnrollmentAvailableRenewalIdIdGetRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentAvailableRenewalIdIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentAvailableRenewalIdIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentAvailableRenewalIdIdGetRequest) Execute() (*ModelsEnrollmentAvailableRenewal, *http.Response, error) {
	return r.ApiService.EnrollmentAvailableRenewalIdIdGetExecute(r)
}

/*
EnrollmentAvailableRenewalIdIdGet Returns the type of renewal available for a given certificate.

### Available Renewal Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 0              | None                 |
| 1             | Seeded PFX                |
| 2                | One-click                   |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Keyfactor certificate Id
	@return ApiEnrollmentAvailableRenewalIdIdGetRequest
*/
func (a *EnrollmentApiService) EnrollmentAvailableRenewalIdIdGet(ctx context.Context, id int32) ApiEnrollmentAvailableRenewalIdIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentAvailableRenewalIdIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return ModelsEnrollmentAvailableRenewal
func (a *EnrollmentApiService) EnrollmentAvailableRenewalIdIdGetExecute(r ApiEnrollmentAvailableRenewalIdIdGetRequest) (*ModelsEnrollmentAvailableRenewal, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ModelsEnrollmentAvailableRenewal
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/AvailableRenewal/Id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 0 {
		return localVarReturnValue, nil, reportError("id must be greater than 0")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest struct {
	ctx                     context.Context
	ApiService              *EnrollmentApiService
	thumbprint              string
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The collection id for the given certificate
func (r ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest) CollectionId(collectionId int32) ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest) Execute() (*ModelsEnrollmentAvailableRenewal, *http.Response, error) {
	return r.ApiService.EnrollmentAvailableRenewalThumbprintThumbprintGetExecute(r)
}

/*
EnrollmentAvailableRenewalThumbprintThumbprintGet Returns the type of renewal available for a given certificate.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param thumbprint The certificate thumbprint
	@return ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest
*/
func (a *EnrollmentApiService) EnrollmentAvailableRenewalThumbprintThumbprintGet(ctx context.Context, thumbprint string) ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		thumbprint:              thumbprint,
	}
}

// Execute executes the request
//
//	@return ModelsEnrollmentAvailableRenewal
func (a *EnrollmentApiService) EnrollmentAvailableRenewalThumbprintThumbprintGetExecute(r ApiEnrollmentAvailableRenewalThumbprintThumbprintGetRequest) (*ModelsEnrollmentAvailableRenewal, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ModelsEnrollmentAvailableRenewal
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/AvailableRenewal/Thumbprint/{thumbprint}"
	localVarPath = strings.Replace(localVarPath, "{"+"thumbprint"+"}", url.PathEscape(parameterValueToString(r.thumbprint, "thumbprint")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentCSRContextMyGetRequest struct {
	ctx                     context.Context
	ApiService              *EnrollmentApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentCSRContextMyGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentCSRContextMyGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentCSRContextMyGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentCSRContextMyGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentCSRContextMyGetRequest) Execute() (*KeyfactorWebCoreModelsEnrollmentEnrollmentTemplateCAResponse, *http.Response, error) {
	return r.ApiService.EnrollmentCSRContextMyGetExecute(r)
}

/*
EnrollmentCSRContextMyGet Returns the list of available CSR enrollment templates and their associated CA mappings that the calling user has permissions on

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEnrollmentCSRContextMyGetRequest
*/
func (a *EnrollmentApiService) EnrollmentCSRContextMyGet(ctx context.Context) ApiEnrollmentCSRContextMyGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentCSRContextMyGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebCoreModelsEnrollmentEnrollmentTemplateCAResponse
func (a *EnrollmentApiService) EnrollmentCSRContextMyGetExecute(r ApiEnrollmentCSRContextMyGetRequest) (*KeyfactorWebCoreModelsEnrollmentEnrollmentTemplateCAResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebCoreModelsEnrollmentEnrollmentTemplateCAResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/CSR/Context/My"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentCSRParsePostRequest struct {
	ctx                     context.Context
	ApiService              *EnrollmentApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
	modelsCSRContents       *ModelsCSRContents
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentCSRParsePostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentCSRParsePostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentCSRParsePostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentCSRParsePostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// CSR to be parsed
func (r ApiEnrollmentCSRParsePostRequest) ModelsCSRContents(modelsCSRContents ModelsCSRContents) ApiEnrollmentCSRParsePostRequest {
	r.modelsCSRContents = &modelsCSRContents
	return r
}

func (r ApiEnrollmentCSRParsePostRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.EnrollmentCSRParsePostExecute(r)
}

/*
EnrollmentCSRParsePost Parses the provided CSR and returns the properties

This functionality is equivalent to the result of pasting a CSR into the field within the Management Portal CSR Enrollment page.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEnrollmentCSRParsePostRequest
*/
func (a *EnrollmentApiService) EnrollmentCSRParsePost(ctx context.Context) ApiEnrollmentCSRParsePostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentCSRParsePostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []string
func (a *EnrollmentApiService) EnrollmentCSRParsePostExecute(r ApiEnrollmentCSRParsePostRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/CSR/Parse"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.modelsCSRContents
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentCSRPostRequest struct {
	ctx                                  context.Context
	ApiService                           *EnrollmentApiService
	xKeyfactorRequestedWith              *string
	xKeyfactorApiVersion                 *string
	modelsEnrollmentCSREnrollmentRequest *ModelsEnrollmentCSREnrollmentRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentCSRPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentCSRPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentCSRPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentCSRPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information needed to perform the CSR Enrollment
func (r ApiEnrollmentCSRPostRequest) ModelsEnrollmentCSREnrollmentRequest(modelsEnrollmentCSREnrollmentRequest ModelsEnrollmentCSREnrollmentRequest) ApiEnrollmentCSRPostRequest {
	r.modelsEnrollmentCSREnrollmentRequest = &modelsEnrollmentCSREnrollmentRequest
	return r
}

func (r ApiEnrollmentCSRPostRequest) Execute() (*ModelsEnrollmentCSREnrollmentResponse, *http.Response, error) {
	return r.ApiService.EnrollmentCSRPostExecute(r)
}

/*
EnrollmentCSRPost Performs a CSR Enrollment based upon the provided request

### Subject Alternative Name Flags ###
| Value              | Description               |
|--------------------|---------------------------|
| other              | OtherName                 |
| rfc822             | RFC822Name                |
| dns                | DNSName                   |
| x400               | X400Address               |
| directory          | DirectoryName             |
| ediparty           | EdipartyName              |
| uri                | UniformResourceIdentifier |
| ip                 | IPAddress                 |
| ip4                | IPv4Address               |
| ip6                | IPv6Address               |
| registeredid       | RegisteredId              |
| ms_ntprincipalname | MS_NTPrincipalName        |
| ms_ntdsreplication | MS_NTDSReplication        |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEnrollmentCSRPostRequest
*/
func (a *EnrollmentApiService) EnrollmentCSRPost(ctx context.Context) ApiEnrollmentCSRPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentCSRPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return ModelsEnrollmentCSREnrollmentResponse
func (a *EnrollmentApiService) EnrollmentCSRPostExecute(r ApiEnrollmentCSRPostRequest) (*ModelsEnrollmentCSREnrollmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ModelsEnrollmentCSREnrollmentResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/CSR"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.modelsEnrollmentCSREnrollmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentPFXContextMyGetRequest struct {
	ctx                     context.Context
	ApiService              *EnrollmentApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentPFXContextMyGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentPFXContextMyGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentPFXContextMyGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentPFXContextMyGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentPFXContextMyGetRequest) Execute() (*KeyfactorWebCoreModelsEnrollmentEnrollmentTemplateCAResponse, *http.Response, error) {
	return r.ApiService.EnrollmentPFXContextMyGetExecute(r)
}

/*
EnrollmentPFXContextMyGet Returns the list of available PFX enrollment templates and their associated CA mappings that the calling user has permissions on

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEnrollmentPFXContextMyGetRequest
*/
func (a *EnrollmentApiService) EnrollmentPFXContextMyGet(ctx context.Context) ApiEnrollmentPFXContextMyGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentPFXContextMyGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebCoreModelsEnrollmentEnrollmentTemplateCAResponse
func (a *EnrollmentApiService) EnrollmentPFXContextMyGetExecute(r ApiEnrollmentPFXContextMyGetRequest) (*KeyfactorWebCoreModelsEnrollmentEnrollmentTemplateCAResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebCoreModelsEnrollmentEnrollmentTemplateCAResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/PFX/Context/My"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentPFXDeployPostRequest struct {
	ctx                                                                 context.Context
	ApiService                                                          *EnrollmentApiService
	xKeyfactorRequestedWith                                             *string
	xKeyfactorApiVersion                                                *string
	keyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementRequest *KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentPFXDeployPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentPFXDeployPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentPFXDeployPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentPFXDeployPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The request to create the management jobs, which includes the request Id of the new pfx and the Ids and management job properties of the cert stores to add the pfx to
func (r ApiEnrollmentPFXDeployPostRequest) KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementRequest(keyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementRequest KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementRequest) ApiEnrollmentPFXDeployPostRequest {
	r.keyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementRequest = &keyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementRequest
	return r
}

func (r ApiEnrollmentPFXDeployPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementResponse, *http.Response, error) {
	return r.ApiService.EnrollmentPFXDeployPostExecute(r)
}

/*
EnrollmentPFXDeployPost Creates management jobs to install a newly enrolled pfx in to one or more certificate stores

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEnrollmentPFXDeployPostRequest
*/
func (a *EnrollmentApiService) EnrollmentPFXDeployPost(ctx context.Context) ApiEnrollmentPFXDeployPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentPFXDeployPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementResponse
func (a *EnrollmentApiService) EnrollmentPFXDeployPostExecute(r ApiEnrollmentPFXDeployPostRequest) (*KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/PFX/Deploy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentPFXPostRequest struct {
	ctx                                  context.Context
	ApiService                           *EnrollmentApiService
	xKeyfactorRequestedWith              *string
	xKeyfactorApiVersion                 *string
	modelsEnrollmentPFXEnrollmentRequest *ModelsEnrollmentPFXEnrollmentRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentPFXPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentPFXPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentPFXPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentPFXPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The information needed to perform the PFX Enrollment
func (r ApiEnrollmentPFXPostRequest) ModelsEnrollmentPFXEnrollmentRequest(modelsEnrollmentPFXEnrollmentRequest ModelsEnrollmentPFXEnrollmentRequest) ApiEnrollmentPFXPostRequest {
	r.modelsEnrollmentPFXEnrollmentRequest = &modelsEnrollmentPFXEnrollmentRequest
	return r
}

func (r ApiEnrollmentPFXPostRequest) Execute() (*ModelsEnrollmentPFXEnrollmentResponse, *http.Response, error) {
	return r.ApiService.EnrollmentPFXPostExecute(r)
}

/*
EnrollmentPFXPost Performs a PFX Enrollment based upon the provided request

### IMPORTANT:
- The <b>'RenewalCertificateId'</b> field in the request should be set to <b>null</b> if the certificate is not being renewed as part of the enrollment. A value of <b>0</b> will produce an error.

### Subject Alternative Name Flags ###
| Value              | Description               |
|--------------------|---------------------------|
| other              | OtherName                 |
| rfc822             | RFC822Name                |
| dns                | DNSName                   |
| x400               | X400Address               |
| directory          | DirectoryName             |
| ediparty           | EdipartyName              |
| uri                | UniformResourceIdentifier |
| ip                 | IPAddress                 |
| ip4                | IPv4Address               |
| ip6                | IPv6Address               |
| registeredid       | RegisteredId              |
| ms_ntprincipalname | MS_NTPrincipalName        |
| ms_ntdsreplication | MS_NTDSReplication        |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEnrollmentPFXPostRequest
*/
func (a *EnrollmentApiService) EnrollmentPFXPost(ctx context.Context) ApiEnrollmentPFXPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentPFXPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return ModelsEnrollmentPFXEnrollmentResponse
func (a *EnrollmentApiService) EnrollmentPFXPostExecute(r ApiEnrollmentPFXPostRequest) (*ModelsEnrollmentPFXEnrollmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ModelsEnrollmentPFXEnrollmentResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/PFX"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.modelsEnrollmentPFXEnrollmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentPFXReplacePostRequest struct {
	ctx                                                 context.Context
	ApiService                                          *EnrollmentApiService
	xKeyfactorRequestedWith                             *string
	xKeyfactorApiVersion                                *string
	modelsEnrollmentExistingEnrollmentManagementRequest *ModelsEnrollmentExistingEnrollmentManagementRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentPFXReplacePostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentPFXReplacePostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentPFXReplacePostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentPFXReplacePostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The request to create the management jobs, which includes the request Id of the new pfx and the Id of the existing certificate
func (r ApiEnrollmentPFXReplacePostRequest) ModelsEnrollmentExistingEnrollmentManagementRequest(modelsEnrollmentExistingEnrollmentManagementRequest ModelsEnrollmentExistingEnrollmentManagementRequest) ApiEnrollmentPFXReplacePostRequest {
	r.modelsEnrollmentExistingEnrollmentManagementRequest = &modelsEnrollmentExistingEnrollmentManagementRequest
	return r
}

func (r ApiEnrollmentPFXReplacePostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementResponse, *http.Response, error) {
	return r.ApiService.EnrollmentPFXReplacePostExecute(r)
}

/*
EnrollmentPFXReplacePost Creates management jobs to install a newly enrolled pfx into the same certificate stores as the previous certificate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEnrollmentPFXReplacePostRequest
*/
func (a *EnrollmentApiService) EnrollmentPFXReplacePost(ctx context.Context) ApiEnrollmentPFXReplacePostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentPFXReplacePostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementResponse
func (a *EnrollmentApiService) EnrollmentPFXReplacePostExecute(r ApiEnrollmentPFXReplacePostRequest) (*KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsEnrollmentEnrollmentManagementResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/PFX/Replace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.modelsEnrollmentExistingEnrollmentManagementRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentRenewPostRequest struct {
	ctx                            context.Context
	ApiService                     *EnrollmentApiService
	xKeyfactorRequestedWith        *string
	collectionId                   *int32
	xKeyfactorApiVersion           *string
	modelsEnrollmentRenewalRequest *ModelsEnrollmentRenewalRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentRenewPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentRenewPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The collection id for the given certificate
func (r ApiEnrollmentRenewPostRequest) CollectionId(collectionId int32) ApiEnrollmentRenewPostRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentRenewPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentRenewPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The information needed to perform the renewal
func (r ApiEnrollmentRenewPostRequest) ModelsEnrollmentRenewalRequest(modelsEnrollmentRenewalRequest ModelsEnrollmentRenewalRequest) ApiEnrollmentRenewPostRequest {
	r.modelsEnrollmentRenewalRequest = &modelsEnrollmentRenewalRequest
	return r
}

func (r ApiEnrollmentRenewPostRequest) Execute() (*ModelsEnrollmentRenewalResponse, *http.Response, error) {
	return r.ApiService.EnrollmentRenewPostExecute(r)
}

/*
EnrollmentRenewPost Performs a renewal based upon the passed in request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiEnrollmentRenewPostRequest
*/
func (a *EnrollmentApiService) EnrollmentRenewPost(ctx context.Context) ApiEnrollmentRenewPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentRenewPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return ModelsEnrollmentRenewalResponse
func (a *EnrollmentApiService) EnrollmentRenewPostExecute(r ApiEnrollmentRenewPostRequest) (*ModelsEnrollmentRenewalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ModelsEnrollmentRenewalResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/Renew"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.modelsEnrollmentRenewalRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnrollmentSettingsIdGetRequest struct {
	ctx                     context.Context
	ApiService              *EnrollmentApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiEnrollmentSettingsIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiEnrollmentSettingsIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiEnrollmentSettingsIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiEnrollmentSettingsIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiEnrollmentSettingsIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsTemplatesEnrollmentTemplateEnrollmentSettingsResponse, *http.Response, error) {
	return r.ApiService.EnrollmentSettingsIdGetExecute(r)
}

/*
EnrollmentSettingsIdGet Gets the template settings to use during enrollment. The response will be the resolved values for the settings.  If there is a template specific setting, the template specific setting will be used in the response.  If there is not a template specific setting, the global setting will be used in the response.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiEnrollmentSettingsIdGetRequest
*/
func (a *EnrollmentApiService) EnrollmentSettingsIdGet(ctx context.Context, id int32) ApiEnrollmentSettingsIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiEnrollmentSettingsIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsTemplatesEnrollmentTemplateEnrollmentSettingsResponse
func (a *EnrollmentApiService) EnrollmentSettingsIdGetExecute(r ApiEnrollmentSettingsIdGetRequest) (*KeyfactorWebKeyfactorApiModelsTemplatesEnrollmentTemplateEnrollmentSettingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsTemplatesEnrollmentTemplateEnrollmentSettingsResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Enrollment/Settings/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 0 {
		return localVarReturnValue, nil, reportError("id must be greater than 0")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
