/*

Copyright 2023 Keyfactor
Licensed under the Apache License, Version 2.0 (the License); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.

Keyfactor API Reference and Utility

<p>This page provides a utility through which the Keyfactor API endpoints can be called and results returned.                                                           It is intended to be used primarily for validation, testing and workflow development.                                                           It also serves secondarily as documentation for the API.</p>                                                          <p>If you would like to view documentation containing details on the Keyfactor API and endpoints,                                                           please refer to the Web API section of the Keyfactor Command documentation.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package command

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// CertificateAuthorityApiService CertificateAuthorityApi service
type CertificateAuthorityApiService service

type ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityAlertRecipientsCAHealthRecipientsGetExecute(r)
}

/*
CertificateAuthorityAlertRecipientsCAHealthRecipientsGet Returns a list of all CA health recipients

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsGetRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAHealthRecipientsGet(ctx context.Context) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAHealthRecipientsGetExecute(r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsGetRequest) ([]KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AlertRecipients/CAHealthRecipients"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteExecute(r)
}

/*
CertificateAuthorityAlertRecipientsCAHealthRecipientsIdDelete Deletes a CA health recipient for the provided ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the health monitoring recipient to delete
	@return ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAHealthRecipientsIdDelete(ctx context.Context, id int32) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteExecute(r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AlertRecipients/CAHealthRecipients/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetExecute(r)
}

/*
CertificateAuthorityAlertRecipientsCAHealthRecipientsIdGet Returns a CA health recipient for the specified health recipient ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the health monitoring recipient to retrieve
	@return ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAHealthRecipientsIdGet(ctx context.Context, id int32) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetExecute(r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdGetRequest) (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AlertRecipients/CAHealthRecipients/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest struct {
	ctx                                                                               context.Context
	ApiService                                                                        *CertificateAuthorityApiService
	id                                                                                int32
	xKeyfactorRequestedWith                                                           *string
	xKeyfactorApiVersion                                                              *string
	keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The request object holding the ID and Email of the health monitoring recipient to be updated
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest) KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest(keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest {
	r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest = &keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest
	return r
}

func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutExecute(r)
}

/*
CertificateAuthorityAlertRecipientsCAHealthRecipientsIdPut Updates a CA health alert recipient for the provided request object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the alert recipient to be updated
	@return ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAHealthRecipientsIdPut(ctx context.Context, id int32) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutExecute(r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsIdPutRequest) (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AlertRecipients/CAHealthRecipients/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest struct {
	ctx                                                                               context.Context
	ApiService                                                                        *CertificateAuthorityApiService
	xKeyfactorRequestedWith                                                           *string
	xKeyfactorApiVersion                                                              *string
	keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The request object holding the email(s) of the health monitoring recipient(s) to be created
func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest) KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest(keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest {
	r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest = &keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest
	return r
}

func (r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityAlertRecipientsCAHealthRecipientsPostExecute(r)
}

/*
CertificateAuthorityAlertRecipientsCAHealthRecipientsPost Creates CA health monitoring recipients for the provided list of email addresses\"

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAHealthRecipientsPost(ctx context.Context) ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAHealthRecipientsPostExecute(r ApiCertificateAuthorityAlertRecipientsCAHealthRecipientsPostRequest) ([]KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AlertRecipients/CAHealthRecipients"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityAlertRecipientsCAThresholdRecipientsGetExecute(r)
}

/*
CertificateAuthorityAlertRecipientsCAThresholdRecipientsGet Returns a list of all CA threshold recipients

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsGetRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAThresholdRecipientsGet(ctx context.Context) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAThresholdRecipientsGetExecute(r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsGetRequest) ([]KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AlertRecipients/CAThresholdRecipients"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteExecute(r)
}

/*
CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDelete Deletes a CA threshold recipient for the provided ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the threshold alert recipient to delete
	@return ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDelete(ctx context.Context, id int32) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteExecute(r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AlertRecipients/CAThresholdRecipients/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetExecute(r)
}

/*
CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGet Returns a CA threshold recipient for the specified threshold alert recipient ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the threshold alert recipient to retrieve
	@return ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGet(ctx context.Context, id int32) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetExecute(r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdGetRequest) (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AlertRecipients/CAThresholdRecipients/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest struct {
	ctx                                                                               context.Context
	ApiService                                                                        *CertificateAuthorityApiService
	id                                                                                int32
	xKeyfactorRequestedWith                                                           *string
	xKeyfactorApiVersion                                                              *string
	keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The request object holding the Email of the alert recipient to be updated
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest) KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest(keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest {
	r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest = &keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest
	return r
}

func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutExecute(r)
}

/*
CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPut Updates a CA threshold alert recipient for the provided request object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the alert recipient to be updated.
	@return ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPut(ctx context.Context, id int32) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutExecute(r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsIdPutRequest) (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AlertRecipients/CAThresholdRecipients/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest struct {
	ctx                                                                               context.Context
	ApiService                                                                        *CertificateAuthorityApiService
	xKeyfactorRequestedWith                                                           *string
	xKeyfactorApiVersion                                                              *string
	keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The request object holding the email(s) of the alert recipient(s) to be created
func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest) KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest(keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest {
	r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest = &keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest
	return r
}

func (r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityAlertRecipientsCAThresholdRecipientsPostExecute(r)
}

/*
CertificateAuthorityAlertRecipientsCAThresholdRecipientsPost Creates CA threshold alert recipients for the provided list of emails

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAThresholdRecipientsPost(ctx context.Context) ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityAlertRecipientsCAThresholdRecipientsPostExecute(r ApiCertificateAuthorityAlertRecipientsCAThresholdRecipientsPostRequest) ([]KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AlertRecipients/CAThresholdRecipients"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCAAlertRecipientCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityAvailableForestsGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityAvailableForestsGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityAvailableForestsGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityAvailableForestsGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityAvailableForestsGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityAvailableForestsGetRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.CertificateAuthorityAvailableForestsGetExecute(r)
}

/*
CertificateAuthorityAvailableForestsGet Returns a list of available forests that are in active directory

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityAvailableForestsGetRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityAvailableForestsGet(ctx context.Context) ApiCertificateAuthorityAvailableForestsGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityAvailableForestsGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []string
func (a *CertificateAuthorityApiService) CertificateAuthorityAvailableForestsGetExecute(r ApiCertificateAuthorityAvailableForestsGetRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/AvailableForests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	xKeyfactorRequestedWith *string
	queryString             *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *KeyfactorCommonQueryableExtensionsSortOrder
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiCertificateAuthorityGetRequest) QueryString(queryString string) ApiCertificateAuthorityGetRequest {
	r.queryString = &queryString
	return r
}

func (r ApiCertificateAuthorityGetRequest) PageReturned(pageReturned int32) ApiCertificateAuthorityGetRequest {
	r.pageReturned = &pageReturned
	return r
}

func (r ApiCertificateAuthorityGetRequest) ReturnLimit(returnLimit int32) ApiCertificateAuthorityGetRequest {
	r.returnLimit = &returnLimit
	return r
}

func (r ApiCertificateAuthorityGetRequest) SortField(sortField string) ApiCertificateAuthorityGetRequest {
	r.sortField = &sortField
	return r
}

func (r ApiCertificateAuthorityGetRequest) SortAscending(sortAscending KeyfactorCommonQueryableExtensionsSortOrder) ApiCertificateAuthorityGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityGetExecute(r)
}

/*
CertificateAuthorityGet Returns all certificate authorities according to the provided filter

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityGetRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityGet(ctx context.Context) ApiCertificateAuthorityGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityGetExecute(r ApiCertificateAuthorityGetRequest) ([]KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.queryString != nil {
		parameterAddToQuery(localVarQueryParams, "QueryString", r.queryString, "")
	}
	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityHealthMonitoringScheduleGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityHealthMonitoringScheduleGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityHealthMonitoringScheduleGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityHealthMonitoringScheduleGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityHealthMonitoringScheduleGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityHealthMonitoringScheduleGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsSchedulingScheduledTaskResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityHealthMonitoringScheduleGetExecute(r)
}

/*
CertificateAuthorityHealthMonitoringScheduleGet Retrieves the execution schedule for the CA health monitoring job

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityHealthMonitoringScheduleGetRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityHealthMonitoringScheduleGet(ctx context.Context) ApiCertificateAuthorityHealthMonitoringScheduleGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityHealthMonitoringScheduleGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsSchedulingScheduledTaskResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityHealthMonitoringScheduleGetExecute(r ApiCertificateAuthorityHealthMonitoringScheduleGetRequest) (*KeyfactorWebKeyfactorApiModelsSchedulingScheduledTaskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsSchedulingScheduledTaskResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/HealthMonitoring/Schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityIdDeleteRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityIdDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityIdDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityIdDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityIdDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateAuthorityIdDeleteExecute(r)
}

/*
CertificateAuthorityIdDelete Deletes a CertificateAuthority from the system, specified by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCertificateAuthorityIdDeleteRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityIdDelete(ctx context.Context, id int32) ApiCertificateAuthorityIdDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
func (a *CertificateAuthorityApiService) CertificateAuthorityIdDeleteExecute(r ApiCertificateAuthorityIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateAuthorityIdGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityIdGetExecute(r)
}

/*
CertificateAuthorityIdGet Returns details for a single CA, specified by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCertificateAuthorityIdGetRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityIdGet(ctx context.Context, id int32) ApiCertificateAuthorityIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityIdGetExecute(r ApiCertificateAuthorityIdGetRequest) (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityImportPostRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	xKeyfactorRequestedWith *string
	dns                     *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityImportPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityImportPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The DNS of the configuration tenant from which to import certificate authorities
func (r ApiCertificateAuthorityImportPostRequest) Dns(dns string) ApiCertificateAuthorityImportPostRequest {
	r.dns = &dns
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityImportPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityImportPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityImportPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateAuthorityImportPostExecute(r)
}

/*
CertificateAuthorityImportPost Imports any certificate authorities from the provided configuration tenant DNS

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityImportPostRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityImportPost(ctx context.Context) ApiCertificateAuthorityImportPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityImportPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateAuthorityApiService) CertificateAuthorityImportPostExecute(r ApiCertificateAuthorityImportPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/Import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.dns != nil {
		parameterAddToQuery(localVarQueryParams, "dns", r.dns, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateAuthorityPostRequest struct {
	ctx                                                                             context.Context
	ApiService                                                                      *CertificateAuthorityApiService
	xKeyfactorRequestedWith                                                         *string
	forceSave                                                                       *bool
	xKeyfactorApiVersion                                                            *string
	keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiCertificateAuthorityPostRequest) ForceSave(forceSave bool) ApiCertificateAuthorityPostRequest {
	r.forceSave = &forceSave
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityPostRequest) KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest(keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest) ApiCertificateAuthorityPostRequest {
	r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest = &keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest
	return r
}

func (r ApiCertificateAuthorityPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityPostExecute(r)
}

/*
CertificateAuthorityPost Creates a new CertificateAuthority object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityPostRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityPost(ctx context.Context) ApiCertificateAuthorityPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityPostExecute(r ApiCertificateAuthorityPostRequest) (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.forceSave != nil {
		parameterAddToQuery(localVarQueryParams, "forceSave", r.forceSave, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityPublishCRLPostRequest struct {
	ctx                                  context.Context
	ApiService                           *CertificateAuthorityApiService
	xKeyfactorRequestedWith              *string
	xKeyfactorApiVersion                 *string
	cSSCMSDataModelModelsCRLRequestModel *CSSCMSDataModelModelsCRLRequestModel
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityPublishCRLPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityPublishCRLPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityPublishCRLPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityPublishCRLPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Host and logical name of the CA for which the CRL should be published
func (r ApiCertificateAuthorityPublishCRLPostRequest) CSSCMSDataModelModelsCRLRequestModel(cSSCMSDataModelModelsCRLRequestModel CSSCMSDataModelModelsCRLRequestModel) ApiCertificateAuthorityPublishCRLPostRequest {
	r.cSSCMSDataModelModelsCRLRequestModel = &cSSCMSDataModelModelsCRLRequestModel
	return r
}

func (r ApiCertificateAuthorityPublishCRLPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateAuthorityPublishCRLPostExecute(r)
}

/*
CertificateAuthorityPublishCRLPost Publishes a CRL according to the provided request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityPublishCRLPostRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityPublishCRLPost(ctx context.Context) ApiCertificateAuthorityPublishCRLPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityPublishCRLPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateAuthorityApiService) CertificateAuthorityPublishCRLPostExecute(r ApiCertificateAuthorityPublishCRLPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/PublishCRL"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsCRLRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateAuthorityPutRequest struct {
	ctx                                                                             context.Context
	ApiService                                                                      *CertificateAuthorityApiService
	xKeyfactorRequestedWith                                                         *string
	forceSave                                                                       *bool
	xKeyfactorApiVersion                                                            *string
	keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiCertificateAuthorityPutRequest) ForceSave(forceSave bool) ApiCertificateAuthorityPutRequest {
	r.forceSave = &forceSave
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthorityPutRequest) KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest(keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest) ApiCertificateAuthorityPutRequest {
	r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest = &keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest
	return r
}

func (r ApiCertificateAuthorityPutRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityPutExecute(r)
}

/*
CertificateAuthorityPut Updates a CertificateAuthority object

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityPutRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityPut(ctx context.Context) ApiCertificateAuthorityPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityPutExecute(r ApiCertificateAuthorityPutRequest) (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.forceSave != nil {
		parameterAddToQuery(localVarQueryParams, "forceSave", r.forceSave, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthoritySourceCountGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateAuthorityApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthoritySourceCountGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthoritySourceCountGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthoritySourceCountGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthoritySourceCountGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateAuthoritySourceCountGetRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.CertificateAuthoritySourceCountGetExecute(r)
}

/*
CertificateAuthoritySourceCountGet Returns a count of certificate authorities with sync enabled

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthoritySourceCountGetRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthoritySourceCountGet(ctx context.Context) ApiCertificateAuthoritySourceCountGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthoritySourceCountGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return int32
func (a *CertificateAuthorityApiService) CertificateAuthoritySourceCountGetExecute(r ApiCertificateAuthoritySourceCountGetRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue int32
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/SourceCount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateAuthorityTestPostRequest struct {
	ctx                                                                        context.Context
	ApiService                                                                 *CertificateAuthorityApiService
	xKeyfactorRequestedWith                                                    *string
	xKeyfactorApiVersion                                                       *string
	cSSCMSDataModelModelsCertificateAuthoritiesCertificateAuthorityTestRequest *CSSCMSDataModelModelsCertificateAuthoritiesCertificateAuthorityTestRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateAuthorityTestPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateAuthorityTestPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateAuthorityTestPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateAuthorityTestPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The CA being tested.
func (r ApiCertificateAuthorityTestPostRequest) CSSCMSDataModelModelsCertificateAuthoritiesCertificateAuthorityTestRequest(cSSCMSDataModelModelsCertificateAuthoritiesCertificateAuthorityTestRequest CSSCMSDataModelModelsCertificateAuthoritiesCertificateAuthorityTestRequest) ApiCertificateAuthorityTestPostRequest {
	r.cSSCMSDataModelModelsCertificateAuthoritiesCertificateAuthorityTestRequest = &cSSCMSDataModelModelsCertificateAuthoritiesCertificateAuthorityTestRequest
	return r
}

func (r ApiCertificateAuthorityTestPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityTestResponse, *http.Response, error) {
	return r.ApiService.CertificateAuthorityTestPostExecute(r)
}

/*
CertificateAuthorityTestPost Validates the connection info for the CA provided by the model.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateAuthorityTestPostRequest
*/
func (a *CertificateAuthorityApiService) CertificateAuthorityTestPost(ctx context.Context) ApiCertificateAuthorityTestPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateAuthorityTestPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityTestResponse
func (a *CertificateAuthorityApiService) CertificateAuthorityTestPostExecute(r ApiCertificateAuthorityTestPostRequest) (*KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityTestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateAuthoritiesCertificateAuthorityTestResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateAuthority/Test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsCertificateAuthoritiesCertificateAuthorityTestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
