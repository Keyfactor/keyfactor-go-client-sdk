/*

Copyright 2023 Keyfactor
Licensed under the Apache License, Version 2.0 (the License); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.

Keyfactor API Reference and Utility

<p>This page provides a utility through which the Keyfactor API endpoints can be called and results returned.                                                           It is intended to be used primarily for validation, testing and workflow development.                                                           It also serves secondarily as documentation for the API.</p>                                                          <p>If you would like to view documentation containing details on the Keyfactor API and endpoints,                                                           please refer to the Web API section of the Keyfactor Command documentation.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package command

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// SecurityApiService SecurityApi service
type SecurityApiService service

type ApiSecurityAuditCollectionsIdGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityAuditCollectionsIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityAuditCollectionsIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityAuditCollectionsIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityAuditCollectionsIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityAuditCollectionsIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateCollectionsCertificateCollectionPermissionsResponse, *http.Response, error) {
	return r.ApiService.SecurityAuditCollectionsIdGetExecute(r)
}

/*
SecurityAuditCollectionsIdGet Gets a list of applicable security permissions for certificate collection

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The certificate collection
	@return ApiSecurityAuditCollectionsIdGetRequest
*/
func (a *SecurityApiService) SecurityAuditCollectionsIdGet(ctx context.Context, id int32) ApiSecurityAuditCollectionsIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityAuditCollectionsIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateCollectionsCertificateCollectionPermissionsResponse
func (a *SecurityApiService) SecurityAuditCollectionsIdGetExecute(r ApiSecurityAuditCollectionsIdGetRequest) (*KeyfactorWebKeyfactorApiModelsCertificateCollectionsCertificateCollectionPermissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateCollectionsCertificateCollectionPermissionsResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Audit/Collections/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityContainersIdRolesGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityContainersIdRolesGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityContainersIdRolesGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityContainersIdRolesGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityContainersIdRolesGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityContainersIdRolesGetRequest) Execute() ([]ModelsCertificateStoreContainerPermissions, *http.Response, error) {
	return r.ApiService.SecurityContainersIdRolesGetExecute(r)
}

/*
SecurityContainersIdRolesGet Returns all the permissions of a certificate store container through the id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Information for the updated container
	@return ApiSecurityContainersIdRolesGetRequest
*/
func (a *SecurityApiService) SecurityContainersIdRolesGet(ctx context.Context, id int32) ApiSecurityContainersIdRolesGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityContainersIdRolesGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []ModelsCertificateStoreContainerPermissions
func (a *SecurityApiService) SecurityContainersIdRolesGetExecute(r ApiSecurityContainersIdRolesGetRequest) ([]ModelsCertificateStoreContainerPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ModelsCertificateStoreContainerPermissions
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Containers/{id}/Roles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityContainersIdRolesPostRequest struct {
	ctx                                        context.Context
	ApiService                                 *SecurityApiService
	id                                         int32
	xKeyfactorRequestedWith                    *string
	xKeyfactorApiVersion                       *string
	modelsCertificateStoreContainerPermissions *[]ModelsCertificateStoreContainerPermissions
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityContainersIdRolesPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityContainersIdRolesPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityContainersIdRolesPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityContainersIdRolesPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information for the updated security role
func (r ApiSecurityContainersIdRolesPostRequest) ModelsCertificateStoreContainerPermissions(modelsCertificateStoreContainerPermissions []ModelsCertificateStoreContainerPermissions) ApiSecurityContainersIdRolesPostRequest {
	r.modelsCertificateStoreContainerPermissions = &modelsCertificateStoreContainerPermissions
	return r
}

func (r ApiSecurityContainersIdRolesPostRequest) Execute() ([]ModelsCertificateStoreContainerPermissions, *http.Response, error) {
	return r.ApiService.SecurityContainersIdRolesPostExecute(r)
}

/*
SecurityContainersIdRolesPost Edit a certificate store container's permissions. Reminder: Name field should be left blank.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Information for the securitycontainer
	@return ApiSecurityContainersIdRolesPostRequest
*/
func (a *SecurityApiService) SecurityContainersIdRolesPost(ctx context.Context, id int32) ApiSecurityContainersIdRolesPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityContainersIdRolesPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []ModelsCertificateStoreContainerPermissions
func (a *SecurityApiService) SecurityContainersIdRolesPostExecute(r ApiSecurityContainersIdRolesPostRequest) ([]ModelsCertificateStoreContainerPermissions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ModelsCertificateStoreContainerPermissions
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Containers/{id}/Roles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.modelsCertificateStoreContainerPermissions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityIdentitiesGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityApiService
	xKeyfactorRequestedWith *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *int32
	validate                *bool
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityIdentitiesGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityIdentitiesGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiSecurityIdentitiesGetRequest) PageReturned(pageReturned int32) ApiSecurityIdentitiesGetRequest {
	r.pageReturned = &pageReturned
	return r
}

func (r ApiSecurityIdentitiesGetRequest) ReturnLimit(returnLimit int32) ApiSecurityIdentitiesGetRequest {
	r.returnLimit = &returnLimit
	return r
}

func (r ApiSecurityIdentitiesGetRequest) SortField(sortField string) ApiSecurityIdentitiesGetRequest {
	r.sortField = &sortField
	return r
}

func (r ApiSecurityIdentitiesGetRequest) SortAscending(sortAscending int32) ApiSecurityIdentitiesGetRequest {
	r.sortAscending = &sortAscending
	return r
}

func (r ApiSecurityIdentitiesGetRequest) Validate(validate bool) ApiSecurityIdentitiesGetRequest {
	r.validate = &validate
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityIdentitiesGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityIdentitiesGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityIdentitiesGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityResponse, *http.Response, error) {
	return r.ApiService.SecurityIdentitiesGetExecute(r)
}

/*
SecurityIdentitiesGet Returns all security identities according to the provided filter and output parameters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecurityIdentitiesGetRequest
*/
func (a *SecurityApiService) SecurityIdentitiesGet(ctx context.Context) ApiSecurityIdentitiesGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityIdentitiesGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityResponse
func (a *SecurityApiService) SecurityIdentitiesGetExecute(r ApiSecurityIdentitiesGetRequest) ([]KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Identities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	if r.validate != nil {
		parameterAddToQuery(localVarQueryParams, "Validate", r.validate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityIdentitiesIdDeleteRequest struct {
	ctx                     context.Context
	ApiService              *SecurityApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityIdentitiesIdDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityIdentitiesIdDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityIdentitiesIdDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityIdentitiesIdDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityIdentitiesIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SecurityIdentitiesIdDeleteExecute(r)
}

/*
SecurityIdentitiesIdDelete Deletes the security identity whose ID is provided.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the security identity to be deleted.
	@return ApiSecurityIdentitiesIdDeleteRequest
*/
func (a *SecurityApiService) SecurityIdentitiesIdDelete(ctx context.Context, id int32) ApiSecurityIdentitiesIdDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityIdentitiesIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
func (a *SecurityApiService) SecurityIdentitiesIdDeleteExecute(r ApiSecurityIdentitiesIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Identities/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSecurityIdentitiesIdGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityIdentitiesIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityIdentitiesIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityIdentitiesIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityIdentitiesIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityIdentitiesIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentityPermissionsSecurityIdentityPermissionsResponse, *http.Response, error) {
	return r.ApiService.SecurityIdentitiesIdGetExecute(r)
}

/*
SecurityIdentitiesIdGet Gets an object representing the permissions of the identity associated with the provided identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The identifier of the security identity
	@return ApiSecurityIdentitiesIdGetRequest
*/
func (a *SecurityApiService) SecurityIdentitiesIdGet(ctx context.Context, id int32) ApiSecurityIdentitiesIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityIdentitiesIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentityPermissionsSecurityIdentityPermissionsResponse
func (a *SecurityApiService) SecurityIdentitiesIdGetExecute(r ApiSecurityIdentitiesIdGetRequest) (*KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentityPermissionsSecurityIdentityPermissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentityPermissionsSecurityIdentityPermissionsResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Identities/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityIdentitiesLookupGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityApiService
	xKeyfactorRequestedWith *string
	accountName             *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityIdentitiesLookupGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityIdentitiesLookupGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The name of an identity we wish to check.
func (r ApiSecurityIdentitiesLookupGetRequest) AccountName(accountName string) ApiSecurityIdentitiesLookupGetRequest {
	r.accountName = &accountName
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityIdentitiesLookupGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityIdentitiesLookupGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityIdentitiesLookupGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityLookupResponse, *http.Response, error) {
	return r.ApiService.SecurityIdentitiesLookupGetExecute(r)
}

/*
SecurityIdentitiesLookupGet Validates that the identity with the name given exists.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecurityIdentitiesLookupGetRequest
*/
func (a *SecurityApiService) SecurityIdentitiesLookupGet(ctx context.Context) ApiSecurityIdentitiesLookupGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityIdentitiesLookupGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityLookupResponse
func (a *SecurityApiService) SecurityIdentitiesLookupGetExecute(r ApiSecurityIdentitiesLookupGetRequest) (*KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityLookupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityLookupResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Identities/Lookup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.accountName != nil {
		parameterAddToQuery(localVarQueryParams, "accountName", r.accountName, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityIdentitiesPostRequest struct {
	ctx                                                                             context.Context
	ApiService                                                                      *SecurityApiService
	xKeyfactorRequestedWith                                                         *string
	xKeyfactorApiVersion                                                            *string
	keyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityRequest *KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityIdentitiesPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityIdentitiesPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityIdentitiesPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityIdentitiesPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Security Identity Request
func (r ApiSecurityIdentitiesPostRequest) KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityRequest(keyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityRequest KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityRequest) ApiSecurityIdentitiesPostRequest {
	r.keyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityRequest = &keyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityRequest
	return r
}

func (r ApiSecurityIdentitiesPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityResponse, *http.Response, error) {
	return r.ApiService.SecurityIdentitiesPostExecute(r)
}

/*
SecurityIdentitiesPost Adds a new security identity to the system.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecurityIdentitiesPostRequest
*/
func (a *SecurityApiService) SecurityIdentitiesPost(ctx context.Context) ApiSecurityIdentitiesPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityIdentitiesPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityResponse
func (a *SecurityApiService) SecurityIdentitiesPostExecute(r ApiSecurityIdentitiesPostRequest) (*KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Identities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsSecuritySecurityIdentitiesSecurityIdentityRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityMyGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityMyGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityMyGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityMyGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityMyGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityMyGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsSecurityLegacySecurityRolesSecurityMyResponse, *http.Response, error) {
	return r.ApiService.SecurityMyGetExecute(r)
}

/*
SecurityMyGet Looks at all the roles and global permissions for the user and returns them.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSecurityMyGetRequest
*/
func (a *SecurityApiService) SecurityMyGet(ctx context.Context) ApiSecurityMyGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityMyGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsSecurityLegacySecurityRolesSecurityMyResponse
func (a *SecurityApiService) SecurityMyGetExecute(r ApiSecurityMyGetRequest) (*KeyfactorWebKeyfactorApiModelsSecurityLegacySecurityRolesSecurityMyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsSecurityLegacySecurityRolesSecurityMyResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/My"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
