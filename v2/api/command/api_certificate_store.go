/*

Copyright 2023 Keyfactor
Licensed under the Apache License, Version 2.0 (the License); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.

Keyfactor API Reference and Utility

<p>This page provides a utility through which the Keyfactor API endpoints can be called and results returned.                                                           It is intended to be used primarily for validation, testing and workflow development.                                                           It also serves secondarily as documentation for the API.</p>                                                          <p>If you would like to view documentation containing details on the Keyfactor API and endpoints,                                                           please refer to the Web API section of the Keyfactor Command documentation.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package command

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// CertificateStoreApiService CertificateStoreApi service
type CertificateStoreApiService service

type ApiCertificateStoresApprovePostRequest struct {
	ctx                                                                           context.Context
	ApiService                                                                    *CertificateStoreApiService
	xKeyfactorRequestedWith                                                       *string
	xKeyfactorApiVersion                                                          *string
	keyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreApproveRequest *[]KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreApproveRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresApprovePostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresApprovePostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresApprovePostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresApprovePostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Certificate stores to be approved
func (r ApiCertificateStoresApprovePostRequest) KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreApproveRequest(keyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreApproveRequest []KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreApproveRequest) ApiCertificateStoresApprovePostRequest {
	r.keyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreApproveRequest = &keyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreApproveRequest
	return r
}

func (r ApiCertificateStoresApprovePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateStoresApprovePostExecute(r)
}

/*
CertificateStoresApprovePost Approves the provided certificate stores to make them available for management

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresApprovePostRequest
*/
func (a *CertificateStoreApiService) CertificateStoresApprovePost(ctx context.Context) ApiCertificateStoresApprovePostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresApprovePostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateStoreApiService) CertificateStoresApprovePostExecute(r ApiCertificateStoresApprovePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/Approve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreApproveRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateStoresAssignContainerPutRequest struct {
	ctx                                      context.Context
	ApiService                               *CertificateStoreApiService
	xKeyfactorRequestedWith                  *string
	xKeyfactorApiVersion                     *string
	cSSCMSDataModelModelsContainerAssignment *CSSCMSDataModelModelsContainerAssignment
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresAssignContainerPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresAssignContainerPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresAssignContainerPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresAssignContainerPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Keyfactor certificate store identifiers and the container properties
func (r ApiCertificateStoresAssignContainerPutRequest) CSSCMSDataModelModelsContainerAssignment(cSSCMSDataModelModelsContainerAssignment CSSCMSDataModelModelsContainerAssignment) ApiCertificateStoresAssignContainerPutRequest {
	r.cSSCMSDataModelModelsContainerAssignment = &cSSCMSDataModelModelsContainerAssignment
	return r
}

func (r ApiCertificateStoresAssignContainerPutRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse, *http.Response, error) {
	return r.ApiService.CertificateStoresAssignContainerPutExecute(r)
}

/*
CertificateStoresAssignContainerPut Assigns the provided certificate stores to the provided container

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresAssignContainerPutRequest
*/
func (a *CertificateStoreApiService) CertificateStoresAssignContainerPut(ctx context.Context) ApiCertificateStoresAssignContainerPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresAssignContainerPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse
func (a *CertificateStoreApiService) CertificateStoresAssignContainerPutExecute(r ApiCertificateStoresAssignContainerPutRequest) ([]KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/AssignContainer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsContainerAssignment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateStoresCertificatesAddPostRequest struct {
	ctx                                                                  context.Context
	ApiService                                                           *CertificateStoreApiService
	xKeyfactorRequestedWith                                              *string
	xKeyfactorApiVersion                                                 *string
	keyfactorWebKeyfactorApiModelsCertificateStoresAddCertificateRequest *KeyfactorWebKeyfactorApiModelsCertificateStoresAddCertificateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresCertificatesAddPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresCertificatesAddPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresCertificatesAddPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresCertificatesAddPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Configuration details of the management job
func (r ApiCertificateStoresCertificatesAddPostRequest) KeyfactorWebKeyfactorApiModelsCertificateStoresAddCertificateRequest(keyfactorWebKeyfactorApiModelsCertificateStoresAddCertificateRequest KeyfactorWebKeyfactorApiModelsCertificateStoresAddCertificateRequest) ApiCertificateStoresCertificatesAddPostRequest {
	r.keyfactorWebKeyfactorApiModelsCertificateStoresAddCertificateRequest = &keyfactorWebKeyfactorApiModelsCertificateStoresAddCertificateRequest
	return r
}

func (r ApiCertificateStoresCertificatesAddPostRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.CertificateStoresCertificatesAddPostExecute(r)
}

/*
CertificateStoresCertificatesAddPost Configures a management job to add a certificate to one or more stores with the provided schedule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresCertificatesAddPostRequest
*/
func (a *CertificateStoreApiService) CertificateStoresCertificatesAddPost(ctx context.Context) ApiCertificateStoresCertificatesAddPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresCertificatesAddPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []string
func (a *CertificateStoreApiService) CertificateStoresCertificatesAddPostExecute(r ApiCertificateStoresCertificatesAddPostRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/Certificates/Add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificateStoresAddCertificateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateStoresCertificatesRemovePostRequest struct {
	ctx                                                                     context.Context
	ApiService                                                              *CertificateStoreApiService
	xKeyfactorRequestedWith                                                 *string
	xKeyfactorApiVersion                                                    *string
	keyfactorWebKeyfactorApiModelsCertificateStoresRemoveCertificateRequest *KeyfactorWebKeyfactorApiModelsCertificateStoresRemoveCertificateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresCertificatesRemovePostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresCertificatesRemovePostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresCertificatesRemovePostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresCertificatesRemovePostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Configuration details of the management job
func (r ApiCertificateStoresCertificatesRemovePostRequest) KeyfactorWebKeyfactorApiModelsCertificateStoresRemoveCertificateRequest(keyfactorWebKeyfactorApiModelsCertificateStoresRemoveCertificateRequest KeyfactorWebKeyfactorApiModelsCertificateStoresRemoveCertificateRequest) ApiCertificateStoresCertificatesRemovePostRequest {
	r.keyfactorWebKeyfactorApiModelsCertificateStoresRemoveCertificateRequest = &keyfactorWebKeyfactorApiModelsCertificateStoresRemoveCertificateRequest
	return r
}

func (r ApiCertificateStoresCertificatesRemovePostRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.CertificateStoresCertificatesRemovePostExecute(r)
}

/*
CertificateStoresCertificatesRemovePost Configures a management job to remove a certificate from one or more stores with the provided schedule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresCertificatesRemovePostRequest
*/
func (a *CertificateStoreApiService) CertificateStoresCertificatesRemovePost(ctx context.Context) ApiCertificateStoresCertificatesRemovePostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresCertificatesRemovePostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []string
func (a *CertificateStoreApiService) CertificateStoresCertificatesRemovePostExecute(r ApiCertificateStoresCertificatesRemovePostRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/Certificates/Remove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificateStoresRemoveCertificateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateStoresDeleteRequest struct {
	ctx                     context.Context
	ApiService              *CertificateStoreApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
	requestBody             *[]string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Array of Keyfactor identifiers (GUID) for the certificate stores to be deleted
func (r ApiCertificateStoresDeleteRequest) RequestBody(requestBody []string) ApiCertificateStoresDeleteRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiCertificateStoresDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateStoresDeleteExecute(r)
}

/*
CertificateStoresDelete Deletes multiple persisted certificate store entities by their identifiers

This will ignore individual delete failures, and continue processing the array.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresDeleteRequest
*/
func (a *CertificateStoreApiService) CertificateStoresDelete(ctx context.Context) ApiCertificateStoresDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateStoreApiService) CertificateStoresDeleteExecute(r ApiCertificateStoresDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateStoresDiscoveryJobPutRequest struct {
	ctx                                      context.Context
	ApiService                               *CertificateStoreApiService
	xKeyfactorRequestedWith                  *string
	xKeyfactorApiVersion                     *string
	cSSCMSDataModelModelsDiscoveryJobRequest *CSSCMSDataModelModelsDiscoveryJobRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresDiscoveryJobPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresDiscoveryJobPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresDiscoveryJobPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresDiscoveryJobPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Configuration properties of the discovery job
func (r ApiCertificateStoresDiscoveryJobPutRequest) CSSCMSDataModelModelsDiscoveryJobRequest(cSSCMSDataModelModelsDiscoveryJobRequest CSSCMSDataModelModelsDiscoveryJobRequest) ApiCertificateStoresDiscoveryJobPutRequest {
	r.cSSCMSDataModelModelsDiscoveryJobRequest = &cSSCMSDataModelModelsDiscoveryJobRequest
	return r
}

func (r ApiCertificateStoresDiscoveryJobPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateStoresDiscoveryJobPutExecute(r)
}

/*
CertificateStoresDiscoveryJobPut Configures a discovery job to locate currently unmanaged certificate stores

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresDiscoveryJobPutRequest
*/
func (a *CertificateStoreApiService) CertificateStoresDiscoveryJobPut(ctx context.Context) ApiCertificateStoresDiscoveryJobPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresDiscoveryJobPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateStoreApiService) CertificateStoresDiscoveryJobPutExecute(r ApiCertificateStoresDiscoveryJobPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/DiscoveryJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsDiscoveryJobRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateStoresGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateStoreApiService
	xKeyfactorRequestedWith *string
	performRoleCheck        *bool
	roleIdList              *[]int32
	queryString             *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *KeyfactorCommonQueryableExtensionsSortOrder
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Set to &#39;true&#39; if role permissions for the current user should be validated
func (r ApiCertificateStoresGetRequest) PerformRoleCheck(performRoleCheck bool) ApiCertificateStoresGetRequest {
	r.performRoleCheck = &performRoleCheck
	return r
}

// List of Keyfactor role identifiers (integer) used to determine permissions if provided
func (r ApiCertificateStoresGetRequest) RoleIdList(roleIdList []int32) ApiCertificateStoresGetRequest {
	r.roleIdList = &roleIdList
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiCertificateStoresGetRequest) QueryString(queryString string) ApiCertificateStoresGetRequest {
	r.queryString = &queryString
	return r
}

// The current page within the result set to be returned
func (r ApiCertificateStoresGetRequest) PageReturned(pageReturned int32) ApiCertificateStoresGetRequest {
	r.pageReturned = &pageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiCertificateStoresGetRequest) ReturnLimit(returnLimit int32) ApiCertificateStoresGetRequest {
	r.returnLimit = &returnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiCertificateStoresGetRequest) SortField(sortField string) ApiCertificateStoresGetRequest {
	r.sortField = &sortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiCertificateStoresGetRequest) SortAscending(sortAscending KeyfactorCommonQueryableExtensionsSortOrder) ApiCertificateStoresGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateStoresGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse, *http.Response, error) {
	return r.ApiService.CertificateStoresGetExecute(r)
}

/*
CertificateStoresGet Returns all certificate stores according to the provided filter and output parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresGetRequest
*/
func (a *CertificateStoreApiService) CertificateStoresGet(ctx context.Context) ApiCertificateStoresGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse
func (a *CertificateStoreApiService) CertificateStoresGetExecute(r ApiCertificateStoresGetRequest) ([]KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.performRoleCheck != nil {
		parameterAddToQuery(localVarQueryParams, "PerformRoleCheck", r.performRoleCheck, "")
	}
	if r.roleIdList != nil {
		t := *r.roleIdList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToQuery(localVarQueryParams, "RoleIdList", s.Index(i), "multi")
			}
		} else {
			parameterAddToQuery(localVarQueryParams, "RoleIdList", t, "multi")
		}
	}
	if r.queryString != nil {
		parameterAddToQuery(localVarQueryParams, "QueryString", r.queryString, "")
	}
	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateStoresIdDeleteRequest struct {
	ctx                     context.Context
	ApiService              *CertificateStoreApiService
	id                      string
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresIdDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresIdDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresIdDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresIdDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateStoresIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateStoresIdDeleteExecute(r)
}

/*
CertificateStoresIdDelete Deletes a persisted certificate store by its Keyfactor identifier

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor certificate store identifier (GUID)
	@return ApiCertificateStoresIdDeleteRequest
*/
func (a *CertificateStoreApiService) CertificateStoresIdDelete(ctx context.Context, id string) ApiCertificateStoresIdDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
func (a *CertificateStoreApiService) CertificateStoresIdDeleteExecute(r ApiCertificateStoresIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateStoresIdGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateStoreApiService
	id                      string
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateStoresIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse, *http.Response, error) {
	return r.ApiService.CertificateStoresIdGetExecute(r)
}

/*
CertificateStoresIdGet Returns a single certificate store associated with the provided id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor identifier (GUID) of the certificate store
	@return ApiCertificateStoresIdGetRequest
*/
func (a *CertificateStoreApiService) CertificateStoresIdGet(ctx context.Context, id string) ApiCertificateStoresIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse
func (a *CertificateStoreApiService) CertificateStoresIdGetExecute(r ApiCertificateStoresIdGetRequest) (*KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateStoresIdInventoryGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateStoreApiService
	id                      string
	xKeyfactorRequestedWith *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *KeyfactorCommonQueryableExtensionsSortOrder
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresIdInventoryGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresIdInventoryGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiCertificateStoresIdInventoryGetRequest) PageReturned(pageReturned int32) ApiCertificateStoresIdInventoryGetRequest {
	r.pageReturned = &pageReturned
	return r
}

func (r ApiCertificateStoresIdInventoryGetRequest) ReturnLimit(returnLimit int32) ApiCertificateStoresIdInventoryGetRequest {
	r.returnLimit = &returnLimit
	return r
}

func (r ApiCertificateStoresIdInventoryGetRequest) SortField(sortField string) ApiCertificateStoresIdInventoryGetRequest {
	r.sortField = &sortField
	return r
}

func (r ApiCertificateStoresIdInventoryGetRequest) SortAscending(sortAscending KeyfactorCommonQueryableExtensionsSortOrder) ApiCertificateStoresIdInventoryGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresIdInventoryGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresIdInventoryGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateStoresIdInventoryGetRequest) Execute() ([]CSSCMSDataModelModelsCertificateStoreInventory, *http.Response, error) {
	return r.ApiService.CertificateStoresIdInventoryGetExecute(r)
}

/*
CertificateStoresIdInventoryGet Returns a single certificate store's inventory associated with the provided id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor identifier (GUID) of the certificate store
	@return ApiCertificateStoresIdInventoryGetRequest
*/
func (a *CertificateStoreApiService) CertificateStoresIdInventoryGet(ctx context.Context, id string) ApiCertificateStoresIdInventoryGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresIdInventoryGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []CSSCMSDataModelModelsCertificateStoreInventory
func (a *CertificateStoreApiService) CertificateStoresIdInventoryGetExecute(r ApiCertificateStoresIdInventoryGetRequest) ([]CSSCMSDataModelModelsCertificateStoreInventory, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CSSCMSDataModelModelsCertificateStoreInventory
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/{id}/Inventory"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateStoresPasswordPutRequest struct {
	ctx                                              context.Context
	ApiService                                       *CertificateStoreApiService
	xKeyfactorRequestedWith                          *string
	xKeyfactorApiVersion                             *string
	cSSCMSDataModelModelsCertStoreNewPasswordRequest *CSSCMSDataModelModelsCertStoreNewPasswordRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresPasswordPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresPasswordPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresPasswordPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresPasswordPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Identifier of the certificate store and the password to be applied to it
func (r ApiCertificateStoresPasswordPutRequest) CSSCMSDataModelModelsCertStoreNewPasswordRequest(cSSCMSDataModelModelsCertStoreNewPasswordRequest CSSCMSDataModelModelsCertStoreNewPasswordRequest) ApiCertificateStoresPasswordPutRequest {
	r.cSSCMSDataModelModelsCertStoreNewPasswordRequest = &cSSCMSDataModelModelsCertStoreNewPasswordRequest
	return r
}

func (r ApiCertificateStoresPasswordPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateStoresPasswordPutExecute(r)
}

/*
CertificateStoresPasswordPut Sets a password for the requested certificate store

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresPasswordPutRequest
*/
func (a *CertificateStoreApiService) CertificateStoresPasswordPut(ctx context.Context) ApiCertificateStoresPasswordPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresPasswordPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateStoreApiService) CertificateStoresPasswordPutExecute(r ApiCertificateStoresPasswordPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/Password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsCertStoreNewPasswordRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateStoresPostRequest struct {
	ctx                                                                 context.Context
	ApiService                                                          *CertificateStoreApiService
	xKeyfactorRequestedWith                                             *string
	xKeyfactorApiVersion                                                *string
	cSSCMSDataModelModelsCertificateStoresCertificateStoreCreateRequest *CSSCMSDataModelModelsCertificateStoresCertificateStoreCreateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Certificate store to be created with the provided properties
func (r ApiCertificateStoresPostRequest) CSSCMSDataModelModelsCertificateStoresCertificateStoreCreateRequest(cSSCMSDataModelModelsCertificateStoresCertificateStoreCreateRequest CSSCMSDataModelModelsCertificateStoresCertificateStoreCreateRequest) ApiCertificateStoresPostRequest {
	r.cSSCMSDataModelModelsCertificateStoresCertificateStoreCreateRequest = &cSSCMSDataModelModelsCertificateStoresCertificateStoreCreateRequest
	return r
}

func (r ApiCertificateStoresPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse, *http.Response, error) {
	return r.ApiService.CertificateStoresPostExecute(r)
}

/*
CertificateStoresPost Creates a new certificate store with the provided properties

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresPostRequest
*/
func (a *CertificateStoreApiService) CertificateStoresPost(ctx context.Context) ApiCertificateStoresPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse
func (a *CertificateStoreApiService) CertificateStoresPostExecute(r ApiCertificateStoresPostRequest) (*KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsCertificateStoresCertificateStoreCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateStoresPutRequest struct {
	ctx                                                                 context.Context
	ApiService                                                          *CertificateStoreApiService
	xKeyfactorRequestedWith                                             *string
	xKeyfactorApiVersion                                                *string
	cSSCMSDataModelModelsCertificateStoresCertificateStoreUpdateRequest *CSSCMSDataModelModelsCertificateStoresCertificateStoreUpdateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Certificate store to be updated with the provided properties
func (r ApiCertificateStoresPutRequest) CSSCMSDataModelModelsCertificateStoresCertificateStoreUpdateRequest(cSSCMSDataModelModelsCertificateStoresCertificateStoreUpdateRequest CSSCMSDataModelModelsCertificateStoresCertificateStoreUpdateRequest) ApiCertificateStoresPutRequest {
	r.cSSCMSDataModelModelsCertificateStoresCertificateStoreUpdateRequest = &cSSCMSDataModelModelsCertificateStoresCertificateStoreUpdateRequest
	return r
}

func (r ApiCertificateStoresPutRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse, *http.Response, error) {
	return r.ApiService.CertificateStoresPutExecute(r)
}

/*
CertificateStoresPut Updates a given certificate store with the properties of the provided instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresPutRequest
*/
func (a *CertificateStoreApiService) CertificateStoresPut(ctx context.Context) ApiCertificateStoresPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse
func (a *CertificateStoreApiService) CertificateStoresPutExecute(r ApiCertificateStoresPutRequest) (*KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificateStoresCertificateStoreResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsCertificateStoresCertificateStoreUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateStoresReenrollmentPostRequest struct {
	ctx                                                                context.Context
	ApiService                                                         *CertificateStoreApiService
	xKeyfactorRequestedWith                                            *string
	xKeyfactorApiVersion                                               *string
	keyfactorWebKeyfactorApiModelsCertificateStoresReenrollmentRequest *KeyfactorWebKeyfactorApiModelsCertificateStoresReenrollmentRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresReenrollmentPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresReenrollmentPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresReenrollmentPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresReenrollmentPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// An object that contains a Keystore Id, a Agent Guid, a string SubjectName and string Alias
func (r ApiCertificateStoresReenrollmentPostRequest) KeyfactorWebKeyfactorApiModelsCertificateStoresReenrollmentRequest(keyfactorWebKeyfactorApiModelsCertificateStoresReenrollmentRequest KeyfactorWebKeyfactorApiModelsCertificateStoresReenrollmentRequest) ApiCertificateStoresReenrollmentPostRequest {
	r.keyfactorWebKeyfactorApiModelsCertificateStoresReenrollmentRequest = &keyfactorWebKeyfactorApiModelsCertificateStoresReenrollmentRequest
	return r
}

func (r ApiCertificateStoresReenrollmentPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateStoresReenrollmentPostExecute(r)
}

/*
CertificateStoresReenrollmentPost Schedules a certificate store for reenrollment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresReenrollmentPostRequest
*/
func (a *CertificateStoreApiService) CertificateStoresReenrollmentPost(ctx context.Context) ApiCertificateStoresReenrollmentPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresReenrollmentPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateStoreApiService) CertificateStoresReenrollmentPostExecute(r ApiCertificateStoresReenrollmentPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/Reenrollment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificateStoresReenrollmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateStoresSchedulePostRequest struct {
	ctx                                     context.Context
	ApiService                              *CertificateStoreApiService
	xKeyfactorRequestedWith                 *string
	xKeyfactorApiVersion                    *string
	cSSCMSDataModelModelsCertStoresSchedule *CSSCMSDataModelModelsCertStoresSchedule
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresSchedulePostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresSchedulePostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresSchedulePostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresSchedulePostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Certificate store identifiers and the desired schedule
func (r ApiCertificateStoresSchedulePostRequest) CSSCMSDataModelModelsCertStoresSchedule(cSSCMSDataModelModelsCertStoresSchedule CSSCMSDataModelModelsCertStoresSchedule) ApiCertificateStoresSchedulePostRequest {
	r.cSSCMSDataModelModelsCertStoresSchedule = &cSSCMSDataModelModelsCertStoresSchedule
	return r
}

func (r ApiCertificateStoresSchedulePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificateStoresSchedulePostExecute(r)
}

/*
CertificateStoresSchedulePost Creates an inventory schedule for the provided certificate stores

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresSchedulePostRequest
*/
func (a *CertificateStoreApiService) CertificateStoresSchedulePost(ctx context.Context) ApiCertificateStoresSchedulePostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresSchedulePostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateStoreApiService) CertificateStoresSchedulePostExecute(r ApiCertificateStoresSchedulePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/Schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsCertStoresSchedule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificateStoresServerGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateStoreApiService
	xKeyfactorRequestedWith *string
	queryString             *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *KeyfactorCommonQueryableExtensionsSortOrder
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresServerGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresServerGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiCertificateStoresServerGetRequest) QueryString(queryString string) ApiCertificateStoresServerGetRequest {
	r.queryString = &queryString
	return r
}

func (r ApiCertificateStoresServerGetRequest) PageReturned(pageReturned int32) ApiCertificateStoresServerGetRequest {
	r.pageReturned = &pageReturned
	return r
}

func (r ApiCertificateStoresServerGetRequest) ReturnLimit(returnLimit int32) ApiCertificateStoresServerGetRequest {
	r.returnLimit = &returnLimit
	return r
}

func (r ApiCertificateStoresServerGetRequest) SortField(sortField string) ApiCertificateStoresServerGetRequest {
	r.sortField = &sortField
	return r
}

func (r ApiCertificateStoresServerGetRequest) SortAscending(sortAscending KeyfactorCommonQueryableExtensionsSortOrder) ApiCertificateStoresServerGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresServerGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresServerGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificateStoresServerGetRequest) Execute() ([]CSSCMSDataModelModelsCertificateStoreServer, *http.Response, error) {
	return r.ApiService.CertificateStoresServerGetExecute(r)
}

/*
CertificateStoresServerGet Returns all certificate store servers according to the provided filter and output parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresServerGetRequest

Deprecated
*/
func (a *CertificateStoreApiService) CertificateStoresServerGet(ctx context.Context) ApiCertificateStoresServerGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresServerGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []CSSCMSDataModelModelsCertificateStoreServer
//
// Deprecated
func (a *CertificateStoreApiService) CertificateStoresServerGetExecute(r ApiCertificateStoresServerGetRequest) ([]CSSCMSDataModelModelsCertificateStoreServer, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CSSCMSDataModelModelsCertificateStoreServer
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/Server"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.queryString != nil {
		parameterAddToQuery(localVarQueryParams, "QueryString", r.queryString, "")
	}
	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateStoresServerPostRequest struct {
	ctx                                                      context.Context
	ApiService                                               *CertificateStoreApiService
	xKeyfactorRequestedWith                                  *string
	xKeyfactorApiVersion                                     *string
	cSSCMSDataModelModelsCertificateStoreCreateServerRequest *CSSCMSDataModelModelsCertificateStoreCreateServerRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresServerPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresServerPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresServerPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresServerPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Certificate store server to be created with the provided properties
func (r ApiCertificateStoresServerPostRequest) CSSCMSDataModelModelsCertificateStoreCreateServerRequest(cSSCMSDataModelModelsCertificateStoreCreateServerRequest CSSCMSDataModelModelsCertificateStoreCreateServerRequest) ApiCertificateStoresServerPostRequest {
	r.cSSCMSDataModelModelsCertificateStoreCreateServerRequest = &cSSCMSDataModelModelsCertificateStoreCreateServerRequest
	return r
}

func (r ApiCertificateStoresServerPostRequest) Execute() (*CSSCMSDataModelModelsCertificateStoreServerResponse, *http.Response, error) {
	return r.ApiService.CertificateStoresServerPostExecute(r)
}

/*
CertificateStoresServerPost Creates a new certificate store server with the provided properties

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresServerPostRequest

Deprecated
*/
func (a *CertificateStoreApiService) CertificateStoresServerPost(ctx context.Context) ApiCertificateStoresServerPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresServerPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsCertificateStoreServerResponse
//
// Deprecated
func (a *CertificateStoreApiService) CertificateStoresServerPostExecute(r ApiCertificateStoresServerPostRequest) (*CSSCMSDataModelModelsCertificateStoreServerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsCertificateStoreServerResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/Server"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsCertificateStoreCreateServerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificateStoresServerPutRequest struct {
	ctx                                                      context.Context
	ApiService                                               *CertificateStoreApiService
	xKeyfactorRequestedWith                                  *string
	xKeyfactorApiVersion                                     *string
	cSSCMSDataModelModelsCertificateStoreUpdateServerRequest *CSSCMSDataModelModelsCertificateStoreUpdateServerRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificateStoresServerPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificateStoresServerPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificateStoresServerPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificateStoresServerPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Server to be updated with the provided properties
func (r ApiCertificateStoresServerPutRequest) CSSCMSDataModelModelsCertificateStoreUpdateServerRequest(cSSCMSDataModelModelsCertificateStoreUpdateServerRequest CSSCMSDataModelModelsCertificateStoreUpdateServerRequest) ApiCertificateStoresServerPutRequest {
	r.cSSCMSDataModelModelsCertificateStoreUpdateServerRequest = &cSSCMSDataModelModelsCertificateStoreUpdateServerRequest
	return r
}

func (r ApiCertificateStoresServerPutRequest) Execute() (*CSSCMSDataModelModelsCertificateStoreServerResponse, *http.Response, error) {
	return r.ApiService.CertificateStoresServerPutExecute(r)
}

/*
CertificateStoresServerPut Updates a given certificate store server with the properties of the provided instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificateStoresServerPutRequest

Deprecated
*/
func (a *CertificateStoreApiService) CertificateStoresServerPut(ctx context.Context) ApiCertificateStoresServerPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificateStoresServerPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsCertificateStoreServerResponse
//
// Deprecated
func (a *CertificateStoreApiService) CertificateStoresServerPutExecute(r ApiCertificateStoresServerPutRequest) (*CSSCMSDataModelModelsCertificateStoreServerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsCertificateStoreServerResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/CertificateStores/Server"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsCertificateStoreUpdateServerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
