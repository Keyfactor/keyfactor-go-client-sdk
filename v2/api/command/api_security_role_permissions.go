/*

Copyright 2023 Keyfactor
Licensed under the Apache License, Version 2.0 (the License); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.

Keyfactor API Reference and Utility

<p>This page provides a utility through which the Keyfactor API endpoints can be called and results returned.                                                           It is intended to be used primarily for validation, testing and workflow development.                                                           It also serves secondarily as documentation for the API.</p>                                                          <p>If you would like to view documentation containing details on the Keyfactor API and endpoints,                                                           please refer to the Web API section of the Keyfactor Command documentation.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package command

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// SecurityRolePermissionsApiService SecurityRolePermissionsApi service
type SecurityRolePermissionsApiService service

type ApiSecurityRolesIdPermissionsCollectionsGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsCollectionsGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsCollectionsGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsCollectionsGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsCollectionsGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolesIdPermissionsCollectionsGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsCollectionsGetExecute(r)
}

/*
SecurityRolesIdPermissionsCollectionsGet Returns all collection permissions associated with the security role that matches the id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsCollectionsGetRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsCollectionsGet(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsCollectionsGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsCollectionsGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsCollectionsGetExecute(r ApiSecurityRolesIdPermissionsCollectionsGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/Collections"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsCollectionsPostRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
	requestBody             *[]map[string]interface{}
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsCollectionsPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsCollectionsPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsCollectionsPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsCollectionsPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Collections permissions
func (r ApiSecurityRolesIdPermissionsCollectionsPostRequest) RequestBody(requestBody []map[string]interface{}) ApiSecurityRolesIdPermissionsCollectionsPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSecurityRolesIdPermissionsCollectionsPostRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsCollectionsPostExecute(r)
}

/*
SecurityRolesIdPermissionsCollectionsPost Adds collection permissions to the security role that matches the id.

### Valid Permissions ###
| Permission    | Permission Display Name   |
|---------------|---------------------------|
| Read          | Read                      |
| EditMetadata  | Edit Metadata             |
| Recover       | Download with Private Key |
| Revoke        | Revoke                    |
| Delete        | Delete                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsCollectionsPostRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsCollectionsPost(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsCollectionsPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsCollectionsPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsCollectionsPostExecute(r ApiSecurityRolesIdPermissionsCollectionsPostRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/Collections"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsCollectionsPutRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
	requestBody             *[]map[string]interface{}
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsCollectionsPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsCollectionsPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsCollectionsPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsCollectionsPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Collections permissions
func (r ApiSecurityRolesIdPermissionsCollectionsPutRequest) RequestBody(requestBody []map[string]interface{}) ApiSecurityRolesIdPermissionsCollectionsPutRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSecurityRolesIdPermissionsCollectionsPutRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsCollectionsPutExecute(r)
}

/*
SecurityRolesIdPermissionsCollectionsPut Sets collection permissions to the security role that matches the id.

### Valid Permissions ###
| Permission    | Permission Display Name   |
|---------------|---------------------------|
| Read          | Read                      |
| EditMetadata  | Edit Metadata             |
| Recover       | Download with Private Key |
| Revoke        | Revoke                    |
| Delete        | Delete                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsCollectionsPutRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsCollectionsPut(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsCollectionsPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsCollectionsPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsCollectionsPutExecute(r ApiSecurityRolesIdPermissionsCollectionsPutRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/Collections"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsContainersGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsContainersGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsContainersGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsContainersGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsContainersGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolesIdPermissionsContainersGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsContainersGetExecute(r)
}

/*
SecurityRolesIdPermissionsContainersGet Returns all container permissions associated with the security role that matches the id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsContainersGetRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsContainersGet(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsContainersGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsContainersGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsContainersGetExecute(r ApiSecurityRolesIdPermissionsContainersGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/Containers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsContainersPostRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
	requestBody             *[]map[string]interface{}
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsContainersPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsContainersPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsContainersPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsContainersPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Container permissions
func (r ApiSecurityRolesIdPermissionsContainersPostRequest) RequestBody(requestBody []map[string]interface{}) ApiSecurityRolesIdPermissionsContainersPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSecurityRolesIdPermissionsContainersPostRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsContainersPostExecute(r)
}

/*
SecurityRolesIdPermissionsContainersPost Adds container permissions to the security role that matches the id.

### Valid Permissions ###
| Permission    | Requisite Permissions |
|---------------|-----------------------|
| Read          |                       |
| Schedule      | Read                  |
| Modify        | Read, Schedule        |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsContainersPostRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsContainersPost(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsContainersPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsContainersPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsContainersPostExecute(r ApiSecurityRolesIdPermissionsContainersPostRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/Containers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsContainersPutRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
	requestBody             *[]map[string]interface{}
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsContainersPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsContainersPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsContainersPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsContainersPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Container permissions
func (r ApiSecurityRolesIdPermissionsContainersPutRequest) RequestBody(requestBody []map[string]interface{}) ApiSecurityRolesIdPermissionsContainersPutRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSecurityRolesIdPermissionsContainersPutRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsContainersPutExecute(r)
}

/*
SecurityRolesIdPermissionsContainersPut Sets container permissions to the security role that matches the id.

### Valid Permissions ###
| Permission    | Requisite Permissions |
|---------------|-----------------------|
| Read          |                       |
| Schedule      | Read                  |
| Modify        | Read, Schedule        |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsContainersPutRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsContainersPut(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsContainersPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsContainersPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsContainersPutExecute(r ApiSecurityRolesIdPermissionsContainersPutRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/Containers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolesIdPermissionsGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsGetExecute(r)
}

/*
SecurityRolesIdPermissionsGet Returns all permissions associated with the security role that matches the id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsGetRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsGet(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsGetExecute(r ApiSecurityRolesIdPermissionsGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsGlobalGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsGlobalGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsGlobalGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsGlobalGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsGlobalGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolesIdPermissionsGlobalGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsGlobalGetExecute(r)
}

/*
SecurityRolesIdPermissionsGlobalGet Returns all global permissions associated with the security role that matches the id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsGlobalGetRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsGlobalGet(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsGlobalGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsGlobalGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsGlobalGetExecute(r ApiSecurityRolesIdPermissionsGlobalGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/Global"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsGlobalPostRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
	requestBody             *[]map[string]interface{}
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsGlobalPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsGlobalPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsGlobalPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsGlobalPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Global permissions
func (r ApiSecurityRolesIdPermissionsGlobalPostRequest) RequestBody(requestBody []map[string]interface{}) ApiSecurityRolesIdPermissionsGlobalPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSecurityRolesIdPermissionsGlobalPostRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsGlobalPostExecute(r)
}

/*
SecurityRolesIdPermissionsGlobalPost Adds global permissions to the security role that matches the id.

### Valid Global Permissions ###
| Area                          | Permission        |
|-------------------------------|-------------------|
| AdminPortal                   | Read              |
| AgentAutoRegistration         | Read              |
| AgentAutoRegistration         | Modify            |
| AgentManagement               | Read              |
| AgentManagement               | Modify            |
| API                           | Read              |
| ApplicationSettings           | Read              |
| ApplicationSettings           | Modify            |
| Auditing                      | Read              |
| CertificateCollections        | Modify            |
| CertificateEnrollment         | EnrollPFX         |
| CertificateEnrollment         | EnrollCSR         |
| CertificateEnrollment         | CsrGeneration     |
| CertificateEnrollment         | PendingCsr        |
| CertificateMetadataTypes      | Read              |
| CertificateMetadataTypes      | Modify            |
| Certificates                  | Read              |
| Certificates                  | EditMetadata      |
| Certificates                  | Import            |
| Certificates                  | Recover           |
| Certificates                  | Revoke            |
| Certificates                  | Delete            |
| Certificates                  | ImportPrivateKey  |
| CertificateStoreManagement    | Read              |
| CertificateStoreManagement    | Schedule          |
| CertificateStoreManagement    | Modify            |
| Dashboard                     | Read              |
| Dashboard                     | RiskHeader        |
| EventHandlerRegistration      | Read              |
| EventHandlerRegistration      | Modify            |
| MacAutoEnrollManagement       | Read              |
| MacAutoEnrollManagement       | Modify            |
| PkiManagement                 | Read              |
| PkiManagement                 | Modify            |
| PrivilegedAccessManagement    | Read              |
| PrivilegedAccessManagement    | Modify            |
| Reports                       | Read              |
| Reports                       | Modify            |
| SecuritySettings              | Read              |
| SecuritySettings              | Modify            |
| SSH                           | User              |
| SSH                           | ServerAdmin       |
| SSH                           | EnterpriseAdmin   |
| SslManagement                 | Read              |
| SslManagement                 | Modify            |
| SystemSettings                | Read              |
| SystemSettings                | Modify            |
| WorkflowDefinitions           | Read              |
| WorkflowDefinitions           | Modify            |
| WorkflowInstances             | ReadAll           |
| WorkflowInstances             | ReadAssignedToMe  |
| WorkflowInstances             | ReadMy            |
| WorkflowInstances             | Manage            |
| WorkflowManagement            | Read              |
| WorkflowManagement            | Modify            |
| WorkflowManagement            | Test              |
| WorkflowManagement            | Participate       |
| WorkflowManagement            | Manage            |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsGlobalPostRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsGlobalPost(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsGlobalPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsGlobalPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsGlobalPostExecute(r ApiSecurityRolesIdPermissionsGlobalPostRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/Global"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsGlobalPutRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
	requestBody             *[]map[string]interface{}
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsGlobalPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsGlobalPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsGlobalPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsGlobalPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Global permissions
func (r ApiSecurityRolesIdPermissionsGlobalPutRequest) RequestBody(requestBody []map[string]interface{}) ApiSecurityRolesIdPermissionsGlobalPutRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSecurityRolesIdPermissionsGlobalPutRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsGlobalPutExecute(r)
}

/*
SecurityRolesIdPermissionsGlobalPut Adds global permissions to the security role that matches the id.

### Valid Global Permissions ###
| Area                          | Permission        |
|-------------------------------|-------------------|
| AdminPortal                   | Read              |
| AgentAutoRegistration         | Read              |
| AgentAutoRegistration         | Modify            |
| AgentManagement               | Read              |
| AgentManagement               | Modify            |
| API                           | Read              |
| ApplicationSettings           | Read              |
| ApplicationSettings           | Modify            |
| Auditing                      | Read              |
| CertificateCollections        | Modify            |
| CertificateEnrollment         | EnrollPFX         |
| CertificateEnrollment         | EnrollCSR         |
| CertificateEnrollment         | CsrGeneration     |
| CertificateEnrollment         | PendingCsr        |
| CertificateMetadataTypes      | Read              |
| CertificateMetadataTypes      | Modify            |
| Certificates                  | Read              |
| Certificates                  | EditMetadata      |
| Certificates                  | Import            |
| Certificates                  | Recover           |
| Certificates                  | Revoke            |
| Certificates                  | Delete            |
| Certificates                  | ImportPrivateKey  |
| CertificateStoreManagement    | Read              |
| CertificateStoreManagement    | Schedule          |
| CertificateStoreManagement    | Modify            |
| Dashboard                     | Read              |
| Dashboard                     | RiskHeader        |
| EventHandlerRegistration      | Read              |
| EventHandlerRegistration      | Modify            |
| MacAutoEnrollManagement       | Read              |
| MacAutoEnrollManagement       | Modify            |
| PkiManagement                 | Read              |
| PkiManagement                 | Modify            |
| PrivilegedAccessManagement    | Read              |
| PrivilegedAccessManagement    | Modify            |
| Reports                       | Read              |
| Reports                       | Modify            |
| SecuritySettings              | Read              |
| SecuritySettings              | Modify            |
| SSH                           | User              |
| SSH                           | ServerAdmin       |
| SSH                           | EnterpriseAdmin   |
| SslManagement                 | Read              |
| SslManagement                 | Modify            |
| SystemSettings                | Read              |
| SystemSettings                | Modify            |
| WorkflowDefinitions           | Read              |
| WorkflowDefinitions           | Modify            |
| WorkflowInstances             | ReadAll           |
| WorkflowInstances             | ReadAssignedToMe  |
| WorkflowInstances             | ReadMy            |
| WorkflowInstances             | Manage            |
| WorkflowManagement            | Read              |
| WorkflowManagement            | Modify            |
| WorkflowManagement            | Test              |
| WorkflowManagement            | Participate       |
| WorkflowManagement            | Manage            |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsGlobalPutRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsGlobalPut(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsGlobalPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsGlobalPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsGlobalPutExecute(r ApiSecurityRolesIdPermissionsGlobalPutRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/Global"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsPamProvidersGetRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsPamProvidersGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsPamProvidersGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsPamProvidersGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsPamProvidersGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiSecurityRolesIdPermissionsPamProvidersGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsSecuritySecurityRolePermissionsPamProviderPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsPamProvidersGetExecute(r)
}

/*
SecurityRolesIdPermissionsPamProvidersGet Returns all PAM provider permissions associated with the security role that matches the id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsPamProvidersGetRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsPamProvidersGet(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsPamProvidersGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsPamProvidersGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsSecuritySecurityRolePermissionsPamProviderPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsPamProvidersGetExecute(r ApiSecurityRolesIdPermissionsPamProvidersGetRequest) ([]KeyfactorWebKeyfactorApiModelsSecuritySecurityRolePermissionsPamProviderPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsSecuritySecurityRolePermissionsPamProviderPermissionResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/PamProviders"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSecurityRolesIdPermissionsPamProvidersPutRequest struct {
	ctx                     context.Context
	ApiService              *SecurityRolePermissionsApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
	requestBody             *[]map[string]interface{}
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiSecurityRolesIdPermissionsPamProvidersPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiSecurityRolesIdPermissionsPamProvidersPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiSecurityRolesIdPermissionsPamProvidersPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiSecurityRolesIdPermissionsPamProvidersPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// PAM Provider permissions
func (r ApiSecurityRolesIdPermissionsPamProvidersPutRequest) RequestBody(requestBody []map[string]interface{}) ApiSecurityRolesIdPermissionsPamProvidersPutRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiSecurityRolesIdPermissionsPamProvidersPutRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsSecuritySecurityRolePermissionsPamProviderPermissionResponse, *http.Response, error) {
	return r.ApiService.SecurityRolesIdPermissionsPamProvidersPutExecute(r)
}

/*
SecurityRolesIdPermissionsPamProvidersPut Sets PAM provider permissions to the security role that matches the id.

### Valid Permissions ###
| Permission    | Requisite Permissions |
|---------------|-----------------------|
| Read          |                       |
| Modify        | Read                  |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Security role identifier
	@return ApiSecurityRolesIdPermissionsPamProvidersPutRequest
*/
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsPamProvidersPut(ctx context.Context, id int32) ApiSecurityRolesIdPermissionsPamProvidersPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiSecurityRolesIdPermissionsPamProvidersPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsSecuritySecurityRolePermissionsPamProviderPermissionResponse
func (a *SecurityRolePermissionsApiService) SecurityRolesIdPermissionsPamProvidersPutExecute(r ApiSecurityRolesIdPermissionsPamProvidersPutRequest) ([]KeyfactorWebKeyfactorApiModelsSecuritySecurityRolePermissionsPamProviderPermissionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsSecuritySecurityRolePermissionsPamProviderPermissionResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Security/Roles/{id}/Permissions/PamProviders"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
