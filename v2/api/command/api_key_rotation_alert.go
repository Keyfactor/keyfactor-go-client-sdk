/*

Copyright 2023 Keyfactor
Licensed under the Apache License, Version 2.0 (the License); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.

Keyfactor API Reference and Utility

<p>This page provides a utility through which the Keyfactor API endpoints can be called and results returned.                                                           It is intended to be used primarily for validation, testing and workflow development.                                                           It also serves secondarily as documentation for the API.</p>                                                          <p>If you would like to view documentation containing details on the Keyfactor API and endpoints,                                                           please refer to the Web API section of the Keyfactor Command documentation.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package command

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// KeyRotationAlertApiService KeyRotationAlertApi service
type KeyRotationAlertApiService service

type ApiAlertsKeyRotationGetRequest struct {
	ctx                     context.Context
	ApiService              *KeyRotationAlertApiService
	xKeyfactorRequestedWith *string
	queryString             *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *KeyfactorCommonQueryableExtensionsSortOrder
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiAlertsKeyRotationGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiAlertsKeyRotationGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiAlertsKeyRotationGetRequest) QueryString(queryString string) ApiAlertsKeyRotationGetRequest {
	r.queryString = &queryString
	return r
}

func (r ApiAlertsKeyRotationGetRequest) PageReturned(pageReturned int32) ApiAlertsKeyRotationGetRequest {
	r.pageReturned = &pageReturned
	return r
}

func (r ApiAlertsKeyRotationGetRequest) ReturnLimit(returnLimit int32) ApiAlertsKeyRotationGetRequest {
	r.returnLimit = &returnLimit
	return r
}

func (r ApiAlertsKeyRotationGetRequest) SortField(sortField string) ApiAlertsKeyRotationGetRequest {
	r.sortField = &sortField
	return r
}

func (r ApiAlertsKeyRotationGetRequest) SortAscending(sortAscending KeyfactorCommonQueryableExtensionsSortOrder) ApiAlertsKeyRotationGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiAlertsKeyRotationGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiAlertsKeyRotationGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiAlertsKeyRotationGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	return r.ApiService.AlertsKeyRotationGetExecute(r)
}

/*
AlertsKeyRotationGet Gets all key rotation alerts according to the provided filter and output parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsKeyRotationGetRequest
*/
func (a *KeyRotationAlertApiService) AlertsKeyRotationGet(ctx context.Context) ApiAlertsKeyRotationGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiAlertsKeyRotationGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
func (a *KeyRotationAlertApiService) AlertsKeyRotationGetExecute(r ApiAlertsKeyRotationGetRequest) ([]KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Alerts/KeyRotation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.queryString != nil {
		parameterAddToQuery(localVarQueryParams, "QueryString", r.queryString, "")
	}
	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsKeyRotationIdDeleteRequest struct {
	ctx                     context.Context
	ApiService              *KeyRotationAlertApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiAlertsKeyRotationIdDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiAlertsKeyRotationIdDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiAlertsKeyRotationIdDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiAlertsKeyRotationIdDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiAlertsKeyRotationIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AlertsKeyRotationIdDeleteExecute(r)
}

/*
AlertsKeyRotationIdDelete Delete a key rotation alert

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id for the key rotation alert
	@return ApiAlertsKeyRotationIdDeleteRequest
*/
func (a *KeyRotationAlertApiService) AlertsKeyRotationIdDelete(ctx context.Context, id int32) ApiAlertsKeyRotationIdDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiAlertsKeyRotationIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
func (a *KeyRotationAlertApiService) AlertsKeyRotationIdDeleteExecute(r ApiAlertsKeyRotationIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Alerts/KeyRotation/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAlertsKeyRotationIdGetRequest struct {
	ctx                     context.Context
	ApiService              *KeyRotationAlertApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiAlertsKeyRotationIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiAlertsKeyRotationIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiAlertsKeyRotationIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiAlertsKeyRotationIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiAlertsKeyRotationIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	return r.ApiService.AlertsKeyRotationIdGetExecute(r)
}

/*
AlertsKeyRotationIdGet Get a key rotation alert

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Id for the key rotation alert to get
	@return ApiAlertsKeyRotationIdGetRequest
*/
func (a *KeyRotationAlertApiService) AlertsKeyRotationIdGet(ctx context.Context, id int32) ApiAlertsKeyRotationIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiAlertsKeyRotationIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
func (a *KeyRotationAlertApiService) AlertsKeyRotationIdGetExecute(r ApiAlertsKeyRotationIdGetRequest) (*KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Alerts/KeyRotation/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsKeyRotationPostRequest struct {
	ctx                                                                            context.Context
	ApiService                                                                     *KeyRotationAlertApiService
	xKeyfactorRequestedWith                                                        *string
	xKeyfactorApiVersion                                                           *string
	keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertCreationRequest *KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertCreationRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiAlertsKeyRotationPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiAlertsKeyRotationPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiAlertsKeyRotationPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiAlertsKeyRotationPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information for the new alert
func (r ApiAlertsKeyRotationPostRequest) KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertCreationRequest(keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertCreationRequest KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertCreationRequest) ApiAlertsKeyRotationPostRequest {
	r.keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertCreationRequest = &keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertCreationRequest
	return r
}

func (r ApiAlertsKeyRotationPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	return r.ApiService.AlertsKeyRotationPostExecute(r)
}

/*
AlertsKeyRotationPost Add a key rotation alert

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsKeyRotationPostRequest
*/
func (a *KeyRotationAlertApiService) AlertsKeyRotationPost(ctx context.Context) ApiAlertsKeyRotationPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiAlertsKeyRotationPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
func (a *KeyRotationAlertApiService) AlertsKeyRotationPostExecute(r ApiAlertsKeyRotationPostRequest) (*KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Alerts/KeyRotation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertCreationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsKeyRotationPutRequest struct {
	ctx                                                                          context.Context
	ApiService                                                                   *KeyRotationAlertApiService
	xKeyfactorRequestedWith                                                      *string
	xKeyfactorApiVersion                                                         *string
	keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertUpdateRequest *KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertUpdateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiAlertsKeyRotationPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiAlertsKeyRotationPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiAlertsKeyRotationPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiAlertsKeyRotationPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information for the key rotation alert
func (r ApiAlertsKeyRotationPutRequest) KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertUpdateRequest(keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertUpdateRequest KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertUpdateRequest) ApiAlertsKeyRotationPutRequest {
	r.keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertUpdateRequest = &keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertUpdateRequest
	return r
}

func (r ApiAlertsKeyRotationPutRequest) Execute() (*KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	return r.ApiService.AlertsKeyRotationPutExecute(r)
}

/*
AlertsKeyRotationPut Edit a key rotation alert

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsKeyRotationPutRequest
*/
func (a *KeyRotationAlertApiService) AlertsKeyRotationPut(ctx context.Context) ApiAlertsKeyRotationPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiAlertsKeyRotationPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
func (a *KeyRotationAlertApiService) AlertsKeyRotationPutExecute(r ApiAlertsKeyRotationPutRequest) (*KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertDefinitionResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Alerts/KeyRotation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsKeyRotationScheduleGetRequest struct {
	ctx                     context.Context
	ApiService              *KeyRotationAlertApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiAlertsKeyRotationScheduleGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiAlertsKeyRotationScheduleGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiAlertsKeyRotationScheduleGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiAlertsKeyRotationScheduleGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiAlertsKeyRotationScheduleGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse, *http.Response, error) {
	return r.ApiService.AlertsKeyRotationScheduleGetExecute(r)
}

/*
AlertsKeyRotationScheduleGet Get the schedule for key rotation alerts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsKeyRotationScheduleGetRequest
*/
func (a *KeyRotationAlertApiService) AlertsKeyRotationScheduleGet(ctx context.Context) ApiAlertsKeyRotationScheduleGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiAlertsKeyRotationScheduleGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse
func (a *KeyRotationAlertApiService) AlertsKeyRotationScheduleGetExecute(r ApiAlertsKeyRotationScheduleGetRequest) (*KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Alerts/KeyRotation/Schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsKeyRotationSchedulePutRequest struct {
	ctx                                                                   context.Context
	ApiService                                                            *KeyRotationAlertApiService
	xKeyfactorRequestedWith                                               *string
	xKeyfactorApiVersion                                                  *string
	keyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleRequest *KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiAlertsKeyRotationSchedulePutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiAlertsKeyRotationSchedulePutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiAlertsKeyRotationSchedulePutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiAlertsKeyRotationSchedulePutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiAlertsKeyRotationSchedulePutRequest) KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleRequest(keyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleRequest KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleRequest) ApiAlertsKeyRotationSchedulePutRequest {
	r.keyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleRequest = &keyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleRequest
	return r
}

func (r ApiAlertsKeyRotationSchedulePutRequest) Execute() (*KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse, *http.Response, error) {
	return r.ApiService.AlertsKeyRotationSchedulePutExecute(r)
}

/*
AlertsKeyRotationSchedulePut Edit schedule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsKeyRotationSchedulePutRequest
*/
func (a *KeyRotationAlertApiService) AlertsKeyRotationSchedulePut(ctx context.Context) ApiAlertsKeyRotationSchedulePutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiAlertsKeyRotationSchedulePutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse
func (a *KeyRotationAlertApiService) AlertsKeyRotationSchedulePutExecute(r ApiAlertsKeyRotationSchedulePutRequest) (*KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Alerts/KeyRotation/Schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsAlertsAlertScheduleAlertScheduleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsKeyRotationTestAllPostRequest struct {
	ctx                                                                           context.Context
	ApiService                                                                    *KeyRotationAlertApiService
	xKeyfactorRequestedWith                                                       *string
	xKeyfactorApiVersion                                                          *string
	keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestAllRequest *KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestAllRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiAlertsKeyRotationTestAllPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiAlertsKeyRotationTestAllPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiAlertsKeyRotationTestAllPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiAlertsKeyRotationTestAllPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Information about the key rotation alert test
func (r ApiAlertsKeyRotationTestAllPostRequest) KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestAllRequest(keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestAllRequest KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestAllRequest) ApiAlertsKeyRotationTestAllPostRequest {
	r.keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestAllRequest = &keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestAllRequest
	return r
}

func (r ApiAlertsKeyRotationTestAllPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse, *http.Response, error) {
	return r.ApiService.AlertsKeyRotationTestAllPostExecute(r)
}

/*
AlertsKeyRotationTestAllPost Test All Alerts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsKeyRotationTestAllPostRequest
*/
func (a *KeyRotationAlertApiService) AlertsKeyRotationTestAllPost(ctx context.Context) ApiAlertsKeyRotationTestAllPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiAlertsKeyRotationTestAllPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse
func (a *KeyRotationAlertApiService) AlertsKeyRotationTestAllPostExecute(r ApiAlertsKeyRotationTestAllPostRequest) (*KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Alerts/KeyRotation/TestAll"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestAllRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAlertsKeyRotationTestPostRequest struct {
	ctx                                                                        context.Context
	ApiService                                                                 *KeyRotationAlertApiService
	xKeyfactorRequestedWith                                                    *string
	xKeyfactorApiVersion                                                       *string
	keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestRequest *KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiAlertsKeyRotationTestPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiAlertsKeyRotationTestPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiAlertsKeyRotationTestPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiAlertsKeyRotationTestPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Parameters used to test the alert
func (r ApiAlertsKeyRotationTestPostRequest) KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestRequest(keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestRequest KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestRequest) ApiAlertsKeyRotationTestPostRequest {
	r.keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestRequest = &keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestRequest
	return r
}

func (r ApiAlertsKeyRotationTestPostRequest) Execute() (*KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse, *http.Response, error) {
	return r.ApiService.AlertsKeyRotationTestPostExecute(r)
}

/*
AlertsKeyRotationTestPost Test An Alert

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAlertsKeyRotationTestPostRequest
*/
func (a *KeyRotationAlertApiService) AlertsKeyRotationTestPost(ctx context.Context) ApiAlertsKeyRotationTestPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiAlertsKeyRotationTestPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse
func (a *KeyRotationAlertApiService) AlertsKeyRotationTestPostExecute(r ApiAlertsKeyRotationTestPostRequest) (*KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Alerts/KeyRotation/Test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsAlertsKeyRotationKeyRotationAlertTestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
