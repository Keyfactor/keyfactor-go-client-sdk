/*

Copyright 2023 Keyfactor
Licensed under the Apache License, Version 2.0 (the License); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
the specific language governing permissions and limitations under the
License.

Keyfactor API Reference and Utility

<p>This page provides a utility through which the Keyfactor API endpoints can be called and results returned.                                                           It is intended to be used primarily for validation, testing and workflow development.                                                           It also serves secondarily as documentation for the API.</p>                                                          <p>If you would like to view documentation containing details on the Keyfactor API and endpoints,                                                           please refer to the Web API section of the Keyfactor Command documentation.</p>

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package command

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// CertificateApiService CertificateApi service
type CertificateApiService service

type ApiCertificatesAnalyzePostRequest struct {
	ctx                                                                 context.Context
	ApiService                                                          *CertificateApiService
	xKeyfactorRequestedWith                                             *string
	xKeyfactorApiVersion                                                *string
	keyfactorWebKeyfactorApiModelsCertificatesAnalyzeCertificateRequest *KeyfactorWebKeyfactorApiModelsCertificatesAnalyzeCertificateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesAnalyzePostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesAnalyzePostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesAnalyzePostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesAnalyzePostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The certificate to analyze
func (r ApiCertificatesAnalyzePostRequest) KeyfactorWebKeyfactorApiModelsCertificatesAnalyzeCertificateRequest(keyfactorWebKeyfactorApiModelsCertificatesAnalyzeCertificateRequest KeyfactorWebKeyfactorApiModelsCertificatesAnalyzeCertificateRequest) ApiCertificatesAnalyzePostRequest {
	r.keyfactorWebKeyfactorApiModelsCertificatesAnalyzeCertificateRequest = &keyfactorWebKeyfactorApiModelsCertificatesAnalyzeCertificateRequest
	return r
}

func (r ApiCertificatesAnalyzePostRequest) Execute() ([]CSSCMSDataModelModelsCertificateDetails, *http.Response, error) {
	return r.ApiService.CertificatesAnalyzePostExecute(r)
}

/*
CertificatesAnalyzePost Returns the public information of the certificate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesAnalyzePostRequest
*/
func (a *CertificateApiService) CertificatesAnalyzePost(ctx context.Context) ApiCertificatesAnalyzePostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesAnalyzePostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []CSSCMSDataModelModelsCertificateDetails
func (a *CertificateApiService) CertificatesAnalyzePostExecute(r ApiCertificatesAnalyzePostRequest) ([]CSSCMSDataModelModelsCertificateDetails, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CSSCMSDataModelModelsCertificateDetails
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/Analyze"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificatesAnalyzeCertificateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesCSVGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	xKeyfactorRequestedWith *string
	sortName                *string
	sortOrder               *KeyfactorCommonQueryableExtensionsSortOrder
	query                   *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesCSVGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesCSVGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiCertificatesCSVGetRequest) SortName(sortName string) ApiCertificatesCSVGetRequest {
	r.sortName = &sortName
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiCertificatesCSVGetRequest) SortOrder(sortOrder KeyfactorCommonQueryableExtensionsSortOrder) ApiCertificatesCSVGetRequest {
	r.sortOrder = &sortOrder
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiCertificatesCSVGetRequest) Query(query string) ApiCertificatesCSVGetRequest {
	r.query = &query
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificat
func (r ApiCertificatesCSVGetRequest) CollectionId(collectionId int32) ApiCertificatesCSVGetRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesCSVGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesCSVGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesCSVGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.CertificatesCSVGetExecute(r)
}

/*
CertificatesCSVGet Returns a comma-delimited CSV file containing all certificates in the database

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesCSVGetRequest
*/
func (a *CertificateApiService) CertificatesCSVGet(ctx context.Context) ApiCertificatesCSVGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesCSVGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return string
func (a *CertificateApiService) CertificatesCSVGetExecute(r ApiCertificatesCSVGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/CSV"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.sortName != nil {
		parameterAddToQuery(localVarQueryParams, "SortName", r.sortName, "")
	}
	if r.sortOrder != nil {
		parameterAddToQuery(localVarQueryParams, "SortOrder", r.sortOrder, "")
	}
	if r.query != nil {
		parameterAddToQuery(localVarQueryParams, "Query", r.query, "")
	}
	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "CollectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesDeleteRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
	requestBody             *[]int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesDeleteRequest) CollectionId(collectionId int32) ApiCertificatesDeleteRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// The array of ids for certificate that are to be deleted
func (r ApiCertificatesDeleteRequest) RequestBody(requestBody []int32) ApiCertificatesDeleteRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiCertificatesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificatesDeleteExecute(r)
}

/*
CertificatesDelete Deletes multiple persisted certificates by their unique ids

This will ignore individual delete failures, and continue processing the array

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesDeleteRequest
*/
func (a *CertificateApiService) CertificatesDelete(ctx context.Context) ApiCertificatesDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificatesDeleteExecute(r ApiCertificatesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificatesDownloadPostRequest struct {
	ctx                                                                  context.Context
	ApiService                                                           *CertificateApiService
	xKeyfactorRequestedWith                                              *string
	collectionId                                                         *int32
	xKeyfactorApiVersion                                                 *string
	keyfactorWebKeyfactorApiModelsCertificatesCertificateDownloadRequest *KeyfactorWebKeyfactorApiModelsCertificatesCertificateDownloadRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesDownloadPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesDownloadPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesDownloadPostRequest) CollectionId(collectionId int32) ApiCertificatesDownloadPostRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesDownloadPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesDownloadPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Query to filter the certificate to be recovered
func (r ApiCertificatesDownloadPostRequest) KeyfactorWebKeyfactorApiModelsCertificatesCertificateDownloadRequest(keyfactorWebKeyfactorApiModelsCertificatesCertificateDownloadRequest KeyfactorWebKeyfactorApiModelsCertificatesCertificateDownloadRequest) ApiCertificatesDownloadPostRequest {
	r.keyfactorWebKeyfactorApiModelsCertificatesCertificateDownloadRequest = &keyfactorWebKeyfactorApiModelsCertificatesCertificateDownloadRequest
	return r
}

func (r ApiCertificatesDownloadPostRequest) Execute() (*CSSCMSDataModelModelsCertificateDownloadResponse, *http.Response, error) {
	return r.ApiService.CertificatesDownloadPostExecute(r)
}

/*
CertificatesDownloadPost Downloads the persisted certificate associated with the provided query

*NOTE: At least one of the following criteria must be provided:
1. Certificate ID
2. Thumbprint
3. Serial number AND Issuer DN (because Serial Number is CA-specific and so is not unique enough on its own)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesDownloadPostRequest
*/
func (a *CertificateApiService) CertificatesDownloadPost(ctx context.Context) ApiCertificatesDownloadPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesDownloadPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsCertificateDownloadResponse
func (a *CertificateApiService) CertificatesDownloadPostExecute(r ApiCertificatesDownloadPostRequest) (*CSSCMSDataModelModelsCertificateDownloadResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsCertificateDownloadResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/Download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificatesCertificateDownloadRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	xKeyfactorRequestedWith *string
	includeRevoked          *bool
	includeExpired          *bool
	queryString             *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *KeyfactorCommonQueryableExtensionsSortOrder
	collectionId            *int32
	includeLocations        *bool
	includeMetadata         *bool
	includeHasPrivateKey    *bool
	verbose                 *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Select &#39;true&#39; to include revoked certificates in the results
func (r ApiCertificatesGetRequest) IncludeRevoked(includeRevoked bool) ApiCertificatesGetRequest {
	r.includeRevoked = &includeRevoked
	return r
}

// Select &#39;true&#39; to include expired certificates in the results
func (r ApiCertificatesGetRequest) IncludeExpired(includeExpired bool) ApiCertificatesGetRequest {
	r.includeExpired = &includeExpired
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiCertificatesGetRequest) QueryString(queryString string) ApiCertificatesGetRequest {
	r.queryString = &queryString
	return r
}

// The current page within the result set to be returned
func (r ApiCertificatesGetRequest) PageReturned(pageReturned int32) ApiCertificatesGetRequest {
	r.pageReturned = &pageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiCertificatesGetRequest) ReturnLimit(returnLimit int32) ApiCertificatesGetRequest {
	r.returnLimit = &returnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiCertificatesGetRequest) SortField(sortField string) ApiCertificatesGetRequest {
	r.sortField = &sortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiCertificatesGetRequest) SortAscending(sortAscending KeyfactorCommonQueryableExtensionsSortOrder) ApiCertificatesGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesGetRequest) CollectionId(collectionId int32) ApiCertificatesGetRequest {
	r.collectionId = &collectionId
	return r
}

// Include locations data for the certificates to be returned
func (r ApiCertificatesGetRequest) IncludeLocations(includeLocations bool) ApiCertificatesGetRequest {
	r.includeLocations = &includeLocations
	return r
}

// Include metadata for the certificates to be returned
func (r ApiCertificatesGetRequest) IncludeMetadata(includeMetadata bool) ApiCertificatesGetRequest {
	r.includeMetadata = &includeMetadata
	return r
}

// Include whether the certificates to be returned have private keys stored in the Keyfactor database
func (r ApiCertificatesGetRequest) IncludeHasPrivateKey(includeHasPrivateKey bool) ApiCertificatesGetRequest {
	r.includeHasPrivateKey = &includeHasPrivateKey
	return r
}

func (r ApiCertificatesGetRequest) Verbose(verbose int32) ApiCertificatesGetRequest {
	r.verbose = &verbose
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesGetRequest) Execute() ([]CSSCMSDataModelModelsCertificateRetrievalResponse, *http.Response, error) {
	return r.ApiService.CertificatesGetExecute(r)
}

/*
CertificatesGet Returns all certificates according to the provided filter and output parameters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesGetRequest
*/
func (a *CertificateApiService) CertificatesGet(ctx context.Context) ApiCertificatesGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return []CSSCMSDataModelModelsCertificateRetrievalResponse
func (a *CertificateApiService) CertificatesGetExecute(r ApiCertificatesGetRequest) ([]CSSCMSDataModelModelsCertificateRetrievalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CSSCMSDataModelModelsCertificateRetrievalResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.includeRevoked != nil {
		parameterAddToQuery(localVarQueryParams, "IncludeRevoked", r.includeRevoked, "")
	}
	if r.includeExpired != nil {
		parameterAddToQuery(localVarQueryParams, "IncludeExpired", r.includeExpired, "")
	}
	if r.queryString != nil {
		parameterAddToQuery(localVarQueryParams, "QueryString", r.queryString, "")
	}
	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	if r.includeLocations != nil {
		parameterAddToQuery(localVarQueryParams, "includeLocations", r.includeLocations, "")
	}
	if r.includeMetadata != nil {
		parameterAddToQuery(localVarQueryParams, "includeMetadata", r.includeMetadata, "")
	}
	if r.includeHasPrivateKey != nil {
		parameterAddToQuery(localVarQueryParams, "includeHasPrivateKey", r.includeHasPrivateKey, "")
	}
	if r.verbose != nil {
		parameterAddToQuery(localVarQueryParams, "verbose", r.verbose, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesIdDeleteRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	id                      int32
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesIdDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesIdDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesIdDeleteRequest) CollectionId(collectionId int32) ApiCertificatesIdDeleteRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesIdDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesIdDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificatesIdDeleteExecute(r)
}

/*
CertificatesIdDelete Deletes a persisted certificate by its unique id as well as the stored private key (if present) associated with it

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor identifier of the certificate record
	@return ApiCertificatesIdDeleteRequest
*/
func (a *CertificateApiService) CertificatesIdDelete(ctx context.Context, id int32) ApiCertificatesIdDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificatesIdDeleteExecute(r ApiCertificatesIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificatesIdGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	id                      int32
	xKeyfactorRequestedWith *string
	includeLocations        *bool
	includeMetadata         *bool
	collectionId            *int32
	verbose                 *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Include locations data for the certificate to be returned
func (r ApiCertificatesIdGetRequest) IncludeLocations(includeLocations bool) ApiCertificatesIdGetRequest {
	r.includeLocations = &includeLocations
	return r
}

// Include metadata for the certificate to be returned
func (r ApiCertificatesIdGetRequest) IncludeMetadata(includeMetadata bool) ApiCertificatesIdGetRequest {
	r.includeMetadata = &includeMetadata
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesIdGetRequest) CollectionId(collectionId int32) ApiCertificatesIdGetRequest {
	r.collectionId = &collectionId
	return r
}

func (r ApiCertificatesIdGetRequest) Verbose(verbose int32) ApiCertificatesIdGetRequest {
	r.verbose = &verbose
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesIdGetRequest) Execute() (*CSSCMSDataModelModelsCertificateRetrievalResponse, *http.Response, error) {
	return r.ApiService.CertificatesIdGetExecute(r)
}

/*
CertificatesIdGet Returns a single certificate that matches the id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor certificate identifier
	@return ApiCertificatesIdGetRequest
*/
func (a *CertificateApiService) CertificatesIdGet(ctx context.Context, id int32) ApiCertificatesIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsCertificateRetrievalResponse
func (a *CertificateApiService) CertificatesIdGetExecute(r ApiCertificatesIdGetRequest) (*CSSCMSDataModelModelsCertificateRetrievalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsCertificateRetrievalResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 0 {
		return localVarReturnValue, nil, reportError("id must be greater than 0")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.includeLocations != nil {
		parameterAddToQuery(localVarQueryParams, "includeLocations", r.includeLocations, "")
	}
	if r.includeMetadata != nil {
		parameterAddToQuery(localVarQueryParams, "includeMetadata", r.includeMetadata, "")
	}
	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	if r.verbose != nil {
		parameterAddToQuery(localVarQueryParams, "verbose", r.verbose, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesIdHistoryGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	id                      int32
	xKeyfactorRequestedWith *string
	pageReturned            *int32
	returnLimit             *int32
	sortField               *string
	sortAscending           *KeyfactorCommonQueryableExtensionsSortOrder
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesIdHistoryGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesIdHistoryGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

func (r ApiCertificatesIdHistoryGetRequest) PageReturned(pageReturned int32) ApiCertificatesIdHistoryGetRequest {
	r.pageReturned = &pageReturned
	return r
}

func (r ApiCertificatesIdHistoryGetRequest) ReturnLimit(returnLimit int32) ApiCertificatesIdHistoryGetRequest {
	r.returnLimit = &returnLimit
	return r
}

func (r ApiCertificatesIdHistoryGetRequest) SortField(sortField string) ApiCertificatesIdHistoryGetRequest {
	r.sortField = &sortField
	return r
}

func (r ApiCertificatesIdHistoryGetRequest) SortAscending(sortAscending KeyfactorCommonQueryableExtensionsSortOrder) ApiCertificatesIdHistoryGetRequest {
	r.sortAscending = &sortAscending
	return r
}

// The collection the certificate could be in.  Defaults to no collection.
func (r ApiCertificatesIdHistoryGetRequest) CollectionId(collectionId int32) ApiCertificatesIdHistoryGetRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesIdHistoryGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesIdHistoryGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesIdHistoryGetRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.CertificatesIdHistoryGetExecute(r)
}

/*
CertificatesIdHistoryGet Gets the history of operations on a certificate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Id of the certificate
	@return ApiCertificatesIdHistoryGetRequest
*/
func (a *CertificateApiService) CertificatesIdHistoryGet(ctx context.Context, id int32) ApiCertificatesIdHistoryGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesIdHistoryGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []map[string]interface{}
func (a *CertificateApiService) CertificatesIdHistoryGetExecute(r ApiCertificatesIdHistoryGetRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []map[string]interface{}
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/{id}/History"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.pageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "PageReturned", r.pageReturned, "")
	}
	if r.returnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "ReturnLimit", r.returnLimit, "")
	}
	if r.sortField != nil {
		parameterAddToQuery(localVarQueryParams, "SortField", r.sortField, "")
	}
	if r.sortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "SortAscending", r.sortAscending, "")
	}
	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesIdSecurityGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	id                      int32
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesIdSecurityGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesIdSecurityGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// The Id of the collection the certificate belongs in. Defaults to no collection
func (r ApiCertificatesIdSecurityGetRequest) CollectionId(collectionId int32) ApiCertificatesIdSecurityGetRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesIdSecurityGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesIdSecurityGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesIdSecurityGetRequest) Execute() (*CSSCMSDataModelModelsSecurityCertificatePermissions, *http.Response, error) {
	return r.ApiService.CertificatesIdSecurityGetExecute(r)
}

/*
CertificatesIdSecurityGet Gets the list of Security Identities and which permissions they have on the given certificate.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Id of the certificate permissions are being checked on
	@return ApiCertificatesIdSecurityGetRequest
*/
func (a *CertificateApiService) CertificatesIdSecurityGet(ctx context.Context, id int32) ApiCertificatesIdSecurityGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesIdSecurityGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsSecurityCertificatePermissions
func (a *CertificateApiService) CertificatesIdSecurityGetExecute(r ApiCertificatesIdSecurityGetRequest) (*CSSCMSDataModelModelsSecurityCertificatePermissions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsSecurityCertificatePermissions
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/{id}/Security"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesIdValidateGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	id                      int32
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesIdValidateGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesIdValidateGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// An optional parameter for the collectin Id the certificate is in.  Defaults to no collection
func (r ApiCertificatesIdValidateGetRequest) CollectionId(collectionId int32) ApiCertificatesIdValidateGetRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesIdValidateGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesIdValidateGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesIdValidateGetRequest) Execute() (*CSSCMSDataModelModelsCertificateValidationResponse, *http.Response, error) {
	return r.ApiService.CertificatesIdValidateGetExecute(r)
}

/*
CertificatesIdValidateGet Validates the certificate chain can be built.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Id of the certificate being checked
	@return ApiCertificatesIdValidateGetRequest
*/
func (a *CertificateApiService) CertificatesIdValidateGet(ctx context.Context, id int32) ApiCertificatesIdValidateGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesIdValidateGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsCertificateValidationResponse
func (a *CertificateApiService) CertificatesIdValidateGetExecute(r ApiCertificatesIdValidateGetRequest) (*CSSCMSDataModelModelsCertificateValidationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsCertificateValidationResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/{id}/Validate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return localVarReturnValue, nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return localVarReturnValue, nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesIdentityAuditIdGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	id                      int32
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesIdentityAuditIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesIdentityAuditIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// An optional parameter for the collectin Id the certificate is in.  Defaults to no collection
func (r ApiCertificatesIdentityAuditIdGetRequest) CollectionId(collectionId int32) ApiCertificatesIdentityAuditIdGetRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesIdentityAuditIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesIdentityAuditIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesIdentityAuditIdGetRequest) Execute() ([]KeyfactorWebKeyfactorApiModelsCertificatesCertificateIdentityAuditResponse, *http.Response, error) {
	return r.ApiService.CertificatesIdentityAuditIdGetExecute(r)
}

/*
CertificatesIdentityAuditIdGet Audit identity permissions for certificate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The Id of the certificate being checked
	@return ApiCertificatesIdentityAuditIdGetRequest
*/
func (a *CertificateApiService) CertificatesIdentityAuditIdGet(ctx context.Context, id int32) ApiCertificatesIdentityAuditIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesIdentityAuditIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return []KeyfactorWebKeyfactorApiModelsCertificatesCertificateIdentityAuditResponse
func (a *CertificateApiService) CertificatesIdentityAuditIdGetExecute(r ApiCertificatesIdentityAuditIdGetRequest) ([]KeyfactorWebKeyfactorApiModelsCertificatesCertificateIdentityAuditResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []KeyfactorWebKeyfactorApiModelsCertificatesCertificateIdentityAuditResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/IdentityAudit/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesImportPostRequest struct {
	ctx                                                context.Context
	ApiService                                         *CertificateApiService
	xKeyfactorRequestedWith                            *string
	xKeyfactorApiVersion                               *string
	cSSCMSDataModelModelsCertificateImportRequestModel *CSSCMSDataModelModelsCertificateImportRequestModel
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesImportPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesImportPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesImportPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesImportPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Request containing the base 64 encoded string and related certificate information, such as certificate stores, metadata, and password
func (r ApiCertificatesImportPostRequest) CSSCMSDataModelModelsCertificateImportRequestModel(cSSCMSDataModelModelsCertificateImportRequestModel CSSCMSDataModelModelsCertificateImportRequestModel) ApiCertificatesImportPostRequest {
	r.cSSCMSDataModelModelsCertificateImportRequestModel = &cSSCMSDataModelModelsCertificateImportRequestModel
	return r
}

func (r ApiCertificatesImportPostRequest) Execute() (*CSSCMSDataModelModelsCertificateImportResponseModel, *http.Response, error) {
	return r.ApiService.CertificatesImportPostExecute(r)
}

/*
CertificatesImportPost Imports the provided certificate into the Keyfactor instance, including any provided associated data

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesImportPostRequest
*/
func (a *CertificateApiService) CertificatesImportPost(ctx context.Context) ApiCertificatesImportPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesImportPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsCertificateImportResponseModel
func (a *CertificateApiService) CertificatesImportPostExecute(r ApiCertificatesImportPostRequest) (*CSSCMSDataModelModelsCertificateImportResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsCertificateImportResponseModel
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/Import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsCertificateImportRequestModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesLocationsIdGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	id                      int32
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesLocationsIdGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesLocationsIdGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesLocationsIdGetRequest) CollectionId(collectionId int32) ApiCertificatesLocationsIdGetRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesLocationsIdGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesLocationsIdGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesLocationsIdGetRequest) Execute() (*KeyfactorWebKeyfactorApiModelsCertificatesCertificateLocationsResponse, *http.Response, error) {
	return r.ApiService.CertificatesLocationsIdGetExecute(r)
}

/*
CertificatesLocationsIdGet Returns a list of locations the certificate is in

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor certificate identifier
	@return ApiCertificatesLocationsIdGetRequest
*/
func (a *CertificateApiService) CertificatesLocationsIdGet(ctx context.Context, id int32) ApiCertificatesLocationsIdGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesLocationsIdGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return KeyfactorWebKeyfactorApiModelsCertificatesCertificateLocationsResponse
func (a *CertificateApiService) CertificatesLocationsIdGetExecute(r ApiCertificatesLocationsIdGetRequest) (*KeyfactorWebKeyfactorApiModelsCertificatesCertificateLocationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorWebKeyfactorApiModelsCertificatesCertificateLocationsResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/Locations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesMetadataAllPutRequest struct {
	ctx                                           context.Context
	ApiService                                    *CertificateApiService
	xKeyfactorRequestedWith                       *string
	collectionId                                  *int32
	xKeyfactorApiVersion                          *string
	cSSCMSDataModelModelsMetadataAllUpdateRequest *CSSCMSDataModelModelsMetadataAllUpdateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesMetadataAllPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesMetadataAllPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesMetadataAllPutRequest) CollectionId(collectionId int32) ApiCertificatesMetadataAllPutRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesMetadataAllPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesMetadataAllPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contains the Keyfactor certificate identifier and the metadata to be updated
func (r ApiCertificatesMetadataAllPutRequest) CSSCMSDataModelModelsMetadataAllUpdateRequest(cSSCMSDataModelModelsMetadataAllUpdateRequest CSSCMSDataModelModelsMetadataAllUpdateRequest) ApiCertificatesMetadataAllPutRequest {
	r.cSSCMSDataModelModelsMetadataAllUpdateRequest = &cSSCMSDataModelModelsMetadataAllUpdateRequest
	return r
}

func (r ApiCertificatesMetadataAllPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificatesMetadataAllPutExecute(r)
}

/*
CertificatesMetadataAllPut Updates the metadata for certificates associated with the certificate identifiers or query provided

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesMetadataAllPutRequest
*/
func (a *CertificateApiService) CertificatesMetadataAllPut(ctx context.Context) ApiCertificatesMetadataAllPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesMetadataAllPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificatesMetadataAllPutExecute(r ApiCertificatesMetadataAllPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/Metadata/All"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsMetadataAllUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificatesMetadataCompareGetRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	certificateId           *int32
	metadataFieldName       *string
	xKeyfactorRequestedWith *string
	value                   *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Certificate identifier
func (r ApiCertificatesMetadataCompareGetRequest) CertificateId(certificateId int32) ApiCertificatesMetadataCompareGetRequest {
	r.certificateId = &certificateId
	return r
}

// Metadata field being compared
func (r ApiCertificatesMetadataCompareGetRequest) MetadataFieldName(metadataFieldName string) ApiCertificatesMetadataCompareGetRequest {
	r.metadataFieldName = &metadataFieldName
	return r
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesMetadataCompareGetRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesMetadataCompareGetRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Value to compare against
func (r ApiCertificatesMetadataCompareGetRequest) Value(value string) ApiCertificatesMetadataCompareGetRequest {
	r.value = &value
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesMetadataCompareGetRequest) CollectionId(collectionId int32) ApiCertificatesMetadataCompareGetRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesMetadataCompareGetRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesMetadataCompareGetRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesMetadataCompareGetRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.CertificatesMetadataCompareGetExecute(r)
}

/*
CertificatesMetadataCompareGet Compares the metadata value provided with the metadata value associated with the specified certificate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesMetadataCompareGetRequest
*/
func (a *CertificateApiService) CertificatesMetadataCompareGet(ctx context.Context) ApiCertificatesMetadataCompareGetRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesMetadataCompareGetRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return bool
func (a *CertificateApiService) CertificatesMetadataCompareGetExecute(r ApiCertificatesMetadataCompareGetRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue bool
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/Metadata/Compare"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.certificateId == nil {
		return localVarReturnValue, nil, reportError("certificateId is required and must be specified")
	}
	if r.metadataFieldName == nil {
		return localVarReturnValue, nil, reportError("metadataFieldName is required and must be specified")
	}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "certificateId", r.certificateId, "")
	parameterAddToQuery(localVarQueryParams, "metadataFieldName", r.metadataFieldName, "")
	if r.value != nil {
		parameterAddToQuery(localVarQueryParams, "value", r.value, "")
	}
	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesMetadataPutRequest struct {
	ctx                                        context.Context
	ApiService                                 *CertificateApiService
	xKeyfactorRequestedWith                    *string
	collectionId                               *int32
	xKeyfactorApiVersion                       *string
	cSSCMSDataModelModelsMetadataUpdateRequest *CSSCMSDataModelModelsMetadataUpdateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesMetadataPutRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesMetadataPutRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesMetadataPutRequest) CollectionId(collectionId int32) ApiCertificatesMetadataPutRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesMetadataPutRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesMetadataPutRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contains the Keyfactor certificate identifier and the metadata to be updated
func (r ApiCertificatesMetadataPutRequest) CSSCMSDataModelModelsMetadataUpdateRequest(cSSCMSDataModelModelsMetadataUpdateRequest CSSCMSDataModelModelsMetadataUpdateRequest) ApiCertificatesMetadataPutRequest {
	r.cSSCMSDataModelModelsMetadataUpdateRequest = &cSSCMSDataModelModelsMetadataUpdateRequest
	return r
}

func (r ApiCertificatesMetadataPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificatesMetadataPutExecute(r)
}

/*
CertificatesMetadataPut Updates the metadata for the certificate associated with the identifier provided

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesMetadataPutRequest
*/
func (a *CertificateApiService) CertificatesMetadataPut(ctx context.Context) ApiCertificatesMetadataPutRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesMetadataPutRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificatesMetadataPutExecute(r ApiCertificatesMetadataPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/Metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsMetadataUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificatesPrivateKeyDeleteRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
	requestBody             *[]int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesPrivateKeyDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesPrivateKeyDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesPrivateKeyDeleteRequest) CollectionId(collectionId int32) ApiCertificatesPrivateKeyDeleteRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesPrivateKeyDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesPrivateKeyDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Keyfactor identifiers of the cetficiates for which the associated private keys should be deleted
func (r ApiCertificatesPrivateKeyDeleteRequest) RequestBody(requestBody []int32) ApiCertificatesPrivateKeyDeleteRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiCertificatesPrivateKeyDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificatesPrivateKeyDeleteExecute(r)
}

/*
CertificatesPrivateKeyDelete Deletes the persisted private keys of multiple certificates by the unique ids of the Certificates

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesPrivateKeyDeleteRequest
*/
func (a *CertificateApiService) CertificatesPrivateKeyDelete(ctx context.Context) ApiCertificatesPrivateKeyDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesPrivateKeyDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificatesPrivateKeyDeleteExecute(r ApiCertificatesPrivateKeyDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/PrivateKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificatesPrivateKeyIdDeleteRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	id                      int32
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesPrivateKeyIdDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesPrivateKeyIdDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesPrivateKeyIdDeleteRequest) CollectionId(collectionId int32) ApiCertificatesPrivateKeyIdDeleteRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesPrivateKeyIdDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesPrivateKeyIdDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiCertificatesPrivateKeyIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificatesPrivateKeyIdDeleteExecute(r)
}

/*
CertificatesPrivateKeyIdDelete Deletes the persisted private key of the certificate associated with the provided identifier

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor identifier of the certificate for which the associated private key should be deleted
	@return ApiCertificatesPrivateKeyIdDeleteRequest
*/
func (a *CertificateApiService) CertificatesPrivateKeyIdDelete(ctx context.Context, id int32) ApiCertificatesPrivateKeyIdDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesPrivateKeyIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
		id:                      id,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificatesPrivateKeyIdDeleteExecute(r ApiCertificatesPrivateKeyIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/PrivateKey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id < 1 {
		return nil, reportError("id must be greater than 1")
	}
	if r.id > 2147483647 {
		return nil, reportError("id must be less than 2147483647")
	}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificatesQueryDeleteRequest struct {
	ctx                     context.Context
	ApiService              *CertificateApiService
	xKeyfactorRequestedWith *string
	collectionId            *int32
	xKeyfactorApiVersion    *string
	body                    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesQueryDeleteRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesQueryDeleteRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesQueryDeleteRequest) CollectionId(collectionId int32) ApiCertificatesQueryDeleteRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesQueryDeleteRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesQueryDeleteRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Query by which certificates should be filtered for deletion
func (r ApiCertificatesQueryDeleteRequest) Body(body string) ApiCertificatesQueryDeleteRequest {
	r.body = &body
	return r
}

func (r ApiCertificatesQueryDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CertificatesQueryDeleteExecute(r)
}

/*
CertificatesQueryDelete Deletes multiple persisted certificate entities selected by a given query

This will ignore individual delete failures, and continue processing the array.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesQueryDeleteRequest
*/
func (a *CertificateApiService) CertificatesQueryDelete(ctx context.Context) ApiCertificatesQueryDeleteRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesQueryDeleteRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
func (a *CertificateApiService) CertificatesQueryDeleteExecute(r ApiCertificatesQueryDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/Query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCertificatesRecoverPostRequest struct {
	ctx                                                                  context.Context
	ApiService                                                           *CertificateApiService
	xKeyfactorRequestedWith                                              *string
	collectionId                                                         *int32
	xKeyfactorApiVersion                                                 *string
	keyfactorWebKeyfactorApiModelsCertificatesCertificateRecoveryRequest *KeyfactorWebKeyfactorApiModelsCertificatesCertificateRecoveryRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesRecoverPostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesRecoverPostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Optional certificate collection identifier used to ensure user access to the certificate
func (r ApiCertificatesRecoverPostRequest) CollectionId(collectionId int32) ApiCertificatesRecoverPostRequest {
	r.collectionId = &collectionId
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesRecoverPostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesRecoverPostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Query to filter the certificate to be recovered
func (r ApiCertificatesRecoverPostRequest) KeyfactorWebKeyfactorApiModelsCertificatesCertificateRecoveryRequest(keyfactorWebKeyfactorApiModelsCertificatesCertificateRecoveryRequest KeyfactorWebKeyfactorApiModelsCertificatesCertificateRecoveryRequest) ApiCertificatesRecoverPostRequest {
	r.keyfactorWebKeyfactorApiModelsCertificatesCertificateRecoveryRequest = &keyfactorWebKeyfactorApiModelsCertificatesCertificateRecoveryRequest
	return r
}

func (r ApiCertificatesRecoverPostRequest) Execute() (*CSSCMSDataModelModelsRecoveryResponse, *http.Response, error) {
	return r.ApiService.CertificatesRecoverPostExecute(r)
}

/*
CertificatesRecoverPost Recovers the persisted certificate associated with the provided query

*NOTE: At least one of the following criteria must be provided:
1. Certificate ID
2. Thumbprint
3. Serial number AND Issuer DN (because Serial Number is CA-specific and so is not unique enough on its own)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesRecoverPostRequest
*/
func (a *CertificateApiService) CertificatesRecoverPost(ctx context.Context) ApiCertificatesRecoverPostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesRecoverPostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsRecoveryResponse
func (a *CertificateApiService) CertificatesRecoverPostExecute(r ApiCertificatesRecoverPostRequest) (*CSSCMSDataModelModelsRecoveryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsRecoveryResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/Recover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.collectionId != nil {
		parameterAddToQuery(localVarQueryParams, "collectionId", r.collectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.keyfactorWebKeyfactorApiModelsCertificatesCertificateRecoveryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCertificatesRevokePostRequest struct {
	ctx                                           context.Context
	ApiService                                    *CertificateApiService
	xKeyfactorRequestedWith                       *string
	xKeyfactorApiVersion                          *string
	cSSCMSDataModelModelsRevokeCertificateRequest *CSSCMSDataModelModelsRevokeCertificateRequest
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiCertificatesRevokePostRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiCertificatesRevokePostRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiCertificatesRevokePostRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiCertificatesRevokePostRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contains the Keyfactor certificate identifiers and revocation data
func (r ApiCertificatesRevokePostRequest) CSSCMSDataModelModelsRevokeCertificateRequest(cSSCMSDataModelModelsRevokeCertificateRequest CSSCMSDataModelModelsRevokeCertificateRequest) ApiCertificatesRevokePostRequest {
	r.cSSCMSDataModelModelsRevokeCertificateRequest = &cSSCMSDataModelModelsRevokeCertificateRequest
	return r
}

func (r ApiCertificatesRevokePostRequest) Execute() (*CSSCMSDataModelModelsRevocationRevocationResponse, *http.Response, error) {
	return r.ApiService.CertificatesRevokePostExecute(r)
}

/*
CertificatesRevokePost Revokes the certificates associated with the provided identifiers and associates the provided data with the revocation

### Revocation Reason Codes for Microsoft CA ###
| Value             | Description               |
|-------------------|---------------------------|
| -1                | Remove from hold          |
| 0                 | Unspecified               |
| 1                 | Key compromised           |
| 2                 | CA compromised            |
| 3                 | Affiliation changed       |
| 4                 | Superceded                |
| 5                 | Cessation of operation    |
| 6                 | Certificate hold          |
| 7                 | Remove from CRL           |
| 999               | Unknown                   |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCertificatesRevokePostRequest
*/
func (a *CertificateApiService) CertificatesRevokePost(ctx context.Context) ApiCertificatesRevokePostRequest {

	xKeyfactorRequestedWith := "APIClient"

	return ApiCertificatesRevokePostRequest{
		ApiService: a,
		ctx:        ctx,

		xKeyfactorRequestedWith: &xKeyfactorRequestedWith,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsRevocationRevocationResponse
func (a *CertificateApiService) CertificatesRevokePostExecute(r ApiCertificatesRevokePostRequest) (*CSSCMSDataModelModelsRevocationRevocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsRevocationRevocationResponse
	)

	apiBasePath := a.client.cfg.APIPath
	if apiBasePath == "" {
		apiBasePath = "/KeyfactorAPI"
	}

	localVarPath := apiBasePath + "/Certificates/Revoke"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.cSSCMSDataModelModelsRevokeCertificateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
