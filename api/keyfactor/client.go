/*
Copyright 2022 Keyfactor
Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
thespecific language governing permissions and limitations under the
License.
Keyfactor-v1

This reference serves to document REST-based methods to manage and integrate with Keyfactor. In addition, an embedded interface allows for the execution of calls against the current Keyfactor API instance.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keyfactor

import (
	"bytes"
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	//"net/http/httputil"
	"net/url"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/Keyfactor/keyfactor-auth-client-go/auth_providers"
)

var (
	jsonCheck       = regexp.MustCompile(`(?i:(?:application|text)/(?:vnd\.[^;]+\+)?json)`)
	xmlCheck        = regexp.MustCompile(`(?i:(?:application|text)/xml)`)
	queryParamSplit = regexp.MustCompile(`(^|&)([^&]+)`)
	queryDescape    = strings.NewReplacer("%5B", "[", "%5D", "]")
)

// APIClient manages communication with the Keyfactor-v1 API vv1
// In most cases there should be only one, shared, APIClient.
type APIClient struct {
	AuthClient AuthConfig
	common     service // Reuse a single struct instead of allocating one for each service on the heap.

	// API Services

	AgentApi *AgentApiService

	AgentBlueprintApi *AgentBlueprintApiService

	AgentPoolApi *AgentPoolApiService

	AuditLogApi *AuditLogApiService

	CSRGenerationApi *CSRGenerationApiService

	CertificateApi *CertificateApiService

	CertificateAuthorityApi *CertificateAuthorityApiService

	CertificateCollectionApi *CertificateCollectionApiService

	CertificateStoreApi *CertificateStoreApiService

	CertificateStoreContainerApi *CertificateStoreContainerApiService

	CertificateStoreTypeApi *CertificateStoreTypeApiService

	CustomJobTypeApi *CustomJobTypeApiService

	DeniedAlertApi *DeniedAlertApiService

	EnrollmentApi *EnrollmentApiService

	ExpirationAlertApi *ExpirationAlertApiService

	IssuedAlertApi *IssuedAlertApiService

	KeyApi *KeyApiService

	KeyRotationAlertApi *KeyRotationAlertApiService

	LicenseApi *LicenseApiService

	LogonApi *LogonApiService

	MacEnrollmentApi *MacEnrollmentApiService

	MetadataFieldApi *MetadataFieldApiService

	MonitoringApi *MonitoringApiService

	OrchestratorJobApi *OrchestratorJobApiService

	PAMProviderApi *PAMProviderApiService

	PendingAlertApi *PendingAlertApiService

	ReportsApi *ReportsApiService

	SMTPApi *SMTPApiService

	SecurityApi *SecurityApiService

	SecurityRolePermissionsApi *SecurityRolePermissionsApiService

	SecurityRolesApi *SecurityRolesApiService

	ServerApi *ServerApiService

	ServerGroupApi *ServerGroupApiService

	ServiceAccountApi *ServiceAccountApiService

	SslApi *SslApiService

	StatusApi *StatusApiService

	TemplateApi *TemplateApiService

	UserApi *UserApiService

	WorkflowApi *WorkflowApiService

	WorkflowDefinitionApi *WorkflowDefinitionApiService

	WorkflowInstanceApi *WorkflowInstanceApiService
}

type service struct {
	client *APIClient
}

// NewAPIClient creates a new API client. Requires a userAgent string describing your application.
// optionally a custom http.Client to allow for advanced features such as caching.
func NewAPIClient(cfg *auth_providers.Server) *APIClient {
	var err error

	authConfig, err := buildHttpClientV2(cfg)
	if err != nil {
		return nil
	}

	c := &APIClient{}
	c.AuthClient = authConfig
	c.common.client = c

	// API Services
	c.AgentApi = (*AgentApiService)(&c.common)
	c.AgentBlueprintApi = (*AgentBlueprintApiService)(&c.common)
	c.AgentPoolApi = (*AgentPoolApiService)(&c.common)
	c.AuditLogApi = (*AuditLogApiService)(&c.common)
	c.CSRGenerationApi = (*CSRGenerationApiService)(&c.common)
	c.CertificateApi = (*CertificateApiService)(&c.common)
	c.CertificateAuthorityApi = (*CertificateAuthorityApiService)(&c.common)
	c.CertificateCollectionApi = (*CertificateCollectionApiService)(&c.common)
	c.CertificateStoreApi = (*CertificateStoreApiService)(&c.common)
	c.CertificateStoreContainerApi = (*CertificateStoreContainerApiService)(&c.common)
	c.CertificateStoreTypeApi = (*CertificateStoreTypeApiService)(&c.common)
	c.CustomJobTypeApi = (*CustomJobTypeApiService)(&c.common)
	c.DeniedAlertApi = (*DeniedAlertApiService)(&c.common)
	c.EnrollmentApi = (*EnrollmentApiService)(&c.common)
	c.ExpirationAlertApi = (*ExpirationAlertApiService)(&c.common)
	c.IssuedAlertApi = (*IssuedAlertApiService)(&c.common)
	c.KeyApi = (*KeyApiService)(&c.common)
	c.KeyRotationAlertApi = (*KeyRotationAlertApiService)(&c.common)
	c.LicenseApi = (*LicenseApiService)(&c.common)
	c.LogonApi = (*LogonApiService)(&c.common)
	c.MacEnrollmentApi = (*MacEnrollmentApiService)(&c.common)
	c.MetadataFieldApi = (*MetadataFieldApiService)(&c.common)
	c.MonitoringApi = (*MonitoringApiService)(&c.common)
	c.OrchestratorJobApi = (*OrchestratorJobApiService)(&c.common)
	c.PAMProviderApi = (*PAMProviderApiService)(&c.common)
	c.PendingAlertApi = (*PendingAlertApiService)(&c.common)
	c.ReportsApi = (*ReportsApiService)(&c.common)
	c.SMTPApi = (*SMTPApiService)(&c.common)
	c.SecurityApi = (*SecurityApiService)(&c.common)
	c.SecurityRolePermissionsApi = (*SecurityRolePermissionsApiService)(&c.common)
	c.SecurityRolesApi = (*SecurityRolesApiService)(&c.common)
	c.ServerApi = (*ServerApiService)(&c.common)
	c.ServerGroupApi = (*ServerGroupApiService)(&c.common)
	c.ServiceAccountApi = (*ServiceAccountApiService)(&c.common)
	c.SslApi = (*SslApiService)(&c.common)
	c.StatusApi = (*StatusApiService)(&c.common)
	c.TemplateApi = (*TemplateApiService)(&c.common)
	c.UserApi = (*UserApiService)(&c.common)
	c.WorkflowApi = (*WorkflowApiService)(&c.common)
	c.WorkflowDefinitionApi = (*WorkflowDefinitionApiService)(&c.common)
	c.WorkflowInstanceApi = (*WorkflowInstanceApiService)(&c.common)

	return c
}

// Define an interface that both CommandConfigOauth and CommandAuthConfigBasic implement
type AuthConfig interface {
	Authenticate() error
	GetHttpClient() (*http.Client, error)
	GetServerConfig() *auth_providers.Server
}

func buildHttpClientV2(cfg *auth_providers.Server) (AuthConfig, error) {
	clientAuthType := cfg.GetAuthType()

	baseConfig := auth_providers.CommandAuthConfig{
		CommandHostName: cfg.Host,
		CommandPort:     cfg.Port,
		CommandAPIPath:  cfg.APIPath,
		CommandCACert:   cfg.CACertPath,
		SkipVerify:      cfg.SkipTLSVerify,
	}

	if clientAuthType == "basic" {
		basicCfg := auth_providers.CommandAuthConfigBasic{
			CommandAuthConfig: baseConfig,
			Username:          cfg.Username,
			Password:          cfg.Password,
			Domain:            cfg.Domain,
		}
		aErr := basicCfg.Authenticate()
		if aErr != nil {
			return nil, aErr
		}
		_, cErr := basicCfg.GetHttpClient()
		if cErr != nil {
			return nil, cErr
		}
		return &basicCfg, nil
	} else if clientAuthType == "oauth" {
		oauthCfg := auth_providers.CommandConfigOauth{
			CommandAuthConfig: baseConfig,
			ClientID:          cfg.ClientID,
			ClientSecret:      cfg.ClientSecret,
			TokenURL:          cfg.OAuthTokenUrl,
		}
		aErr := oauthCfg.Authenticate()
		if aErr != nil {
			return nil, aErr
		}
		_, cErr := oauthCfg.GetHttpClient()
		if cErr != nil {
			return nil, cErr
		}
		return &oauthCfg, nil
	} else {
		return nil, fmt.Errorf("unsupported auth type or authentication AuthClient: '%s'", clientAuthType)
	}
}

func buildHttpClient(config *Configuration) (*http.Client, error) {
	// Configure new TLS object
	tlsConfig := &tls.Config{
		Renegotiation: tls.RenegotiateOnceAsClient,
	}

	// Load the CA certificate
	caChain, err := findCaCertificate(config)
	if err != nil {
		return nil, err
	}

	// Add the CA certificate to the TLS config, if any CA certificate were found
	if len(caChain) > 0 {
		tlsConfig.RootCAs = x509.NewCertPool()
		for _, caCert := range caChain {
			tlsConfig.RootCAs.AddCert(caCert)
		}

		// Add the pool to the TLS config
		tlsConfig.ClientCAs = tlsConfig.RootCAs
	}

	// Configure HTTP transports with TLS config
	customTransport := http.DefaultTransport.(*http.Transport).Clone()
	customTransport.TLSClientConfig = tlsConfig
	customTransport.TLSHandshakeTimeout = 10 * time.Second

	// Build new HTTP object to communicate with EJBCA
	customHttpClient := http.DefaultClient
	customHttpClient.Transport = customTransport
	customHttpClient.Timeout = 10 * time.Second

	return customHttpClient, nil
}

func debugMessage(isDebug bool, message string, args ...interface{}) {
	if isDebug {
		log.Printf(message+"\n", args...)
	}
}

func cleanHostname(hostname string) (string, error) {
	if hostname == "" {
		return "", errors.New("KEYFACTOR_HOSTNAME cannot be empty")
	}

	// When parsing a hostname without a scheme, Go will assume it is a path.
	if !strings.HasPrefix(hostname, "http://") && !strings.HasPrefix(hostname, "https://") {
		hostname = "http://" + hostname
	}

	if u, err := url.Parse(hostname); err == nil {
		return u.Host, nil
	} else {
		fmt.Errorf("%s is not a valid URL: %s", EnvCommandHostname, err)
		return "", err
	}
}

func findCaCertificate(config *Configuration) ([]*x509.Certificate, error) {
	// Load CA certificate
	if config.caCertificates != nil {
		return config.caCertificates, nil
	}

	// If no CA certificate path is specified, return nil since the default CA certificates will be used
	if config.CaCertificatePath == "" {
		return nil, nil
	}

	// Read and parse the passed certificate file which should contain the CA certificate and chain
	debugMessage(config.Debug, "Reading CA certificate from %s", config.CaCertificatePath)
	buf, err := ioutil.ReadFile(config.CaCertificatePath)
	if err != nil {
		return nil, err
	}
	// Decode the PEM encoded certificates into a slice of PEM blocks
	chainBlocks, _, err := decodePEMBytes(buf, config.Debug)
	if err != nil {
		return nil, err
	}
	if len(chainBlocks) <= 0 {
		return nil, fmt.Errorf("didn't find certificate in file at path %s", config.CaCertificatePath)
	}

	caChain := []*x509.Certificate{}
	for _, block := range chainBlocks {
		// Parse the PEM block into an x509 certificate
		cert, err := x509.ParseCertificate(block.Bytes)
		if err != nil {
			return nil, err
		}

		caChain = append(caChain, cert)
	}

	return caChain, nil
}

func decodePEMBytes(buf []byte, isDebug bool) ([]*pem.Block, []byte, error) {
	var privKey []byte
	var certificates []*pem.Block
	var block *pem.Block
	for {
		block, buf = pem.Decode(buf)
		if block == nil {
			break
		} else if strings.Contains(block.Type, "PRIVATE KEY") {
			privKey = pem.EncodeToMemory(block)
		} else {
			certificates = append(certificates, block)
		}
		debugMessage(isDebug, "Found PEM block of type %s", block.Type)
	}
	return certificates, privKey, nil
}

func atoi(in string) (int, error) {
	return strconv.Atoi(in)
}

// selectHeaderContentType select a content type from the available list.
func selectHeaderContentType(contentTypes []string) string {
	if len(contentTypes) == 0 {
		return ""
	}
	if contains(contentTypes, "application/json") {
		return "application/json"
	}
	return contentTypes[0] // use the first content type specified in 'consumes'
}

// selectHeaderAccept join all accept types and return
func selectHeaderAccept(accepts []string) string {
	if len(accepts) == 0 {
		return ""
	}

	if contains(accepts, "application/json") {
		return "application/json"
	}

	return strings.Join(accepts, ",")
}

// contains is a case insensitive match, finding needle in a haystack
func contains(haystack []string, needle string) bool {
	for _, a := range haystack {
		if strings.EqualFold(a, needle) {
			return true
		}
	}
	return false
}

// Verify optional parameters are of the correct type.
func typeCheckParameter(obj interface{}, expected string, name string) error {
	// Make sure there is an object.
	if obj == nil {
		return nil
	}

	// Check the type is as expected.
	if reflect.TypeOf(obj).String() != expected {
		return fmt.Errorf("expected %s to be of type %s but received %s", name, expected, reflect.TypeOf(obj).String())
	}
	return nil
}

func parameterValueToString(obj interface{}, key string) string {
	if reflect.TypeOf(obj).Kind() != reflect.Ptr {
		return fmt.Sprintf("%v", obj)
	}
	var param, ok = obj.(MappedNullable)
	if !ok {
		return ""
	}
	dataMap, err := param.ToMap()
	if err != nil {
		return ""
	}
	return fmt.Sprintf("%v", dataMap[key])
}

// parameterAddToQuery adds the provided object to the url query supporting deep object syntax
func parameterAddToQuery(queryParams interface{}, keyPrefix string, obj interface{}, collectionType string) {
	var v = reflect.ValueOf(obj)
	var value = ""
	if v == reflect.ValueOf(nil) {
		value = "null"
	} else {
		switch v.Kind() {
		case reflect.Invalid:
			value = "invalid"

		case reflect.Struct:
			if t, ok := obj.(MappedNullable); ok {
				dataMap, err := t.ToMap()
				if err != nil {
					return
				}
				parameterAddToQuery(queryParams, keyPrefix, dataMap, collectionType)
				return
			}
			if t, ok := obj.(time.Time); ok {
				parameterAddToQuery(queryParams, keyPrefix, t.Format(time.RFC3339), collectionType)
				return
			}
			value = v.Type().String() + " value"
		case reflect.Slice:
			var indValue = reflect.ValueOf(obj)
			if indValue == reflect.ValueOf(nil) {
				return
			}
			var lenIndValue = indValue.Len()
			for i := 0; i < lenIndValue; i++ {
				var arrayValue = indValue.Index(i)
				parameterAddToQuery(queryParams, keyPrefix, arrayValue.Interface(), collectionType)
			}
			return

		case reflect.Map:
			var indValue = reflect.ValueOf(obj)
			if indValue == reflect.ValueOf(nil) {
				return
			}
			iter := indValue.MapRange()
			for iter.Next() {
				k, v := iter.Key(), iter.Value()
				parameterAddToQuery(
					queryParams,
					fmt.Sprintf("%s[%s]", keyPrefix, k.String()),
					v.Interface(),
					collectionType,
				)
			}
			return

		case reflect.Interface:
			fallthrough
		case reflect.Ptr:
			parameterAddToQuery(queryParams, keyPrefix, v.Elem().Interface(), collectionType)
			return

		case reflect.Int, reflect.Int8, reflect.Int16,
			reflect.Int32, reflect.Int64:
			value = strconv.FormatInt(v.Int(), 10)
		case reflect.Uint, reflect.Uint8, reflect.Uint16,
			reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			value = strconv.FormatUint(v.Uint(), 10)
		case reflect.Float32, reflect.Float64:
			value = strconv.FormatFloat(v.Float(), 'g', -1, 32)
		case reflect.Bool:
			value = strconv.FormatBool(v.Bool())
		case reflect.String:
			value = v.String()
		default:
			value = v.Type().String() + " value"
		}
	}

	switch valuesMap := queryParams.(type) {
	case url.Values:
		valuesMap.Add(keyPrefix, value)
		break
	case map[string]string:
		valuesMap[keyPrefix] = value
		break
	}
}

// helper for converting interface{} parameters to json strings
func parameterToJson(obj interface{}) (string, error) {
	jsonBuf, err := json.Marshal(obj)
	if err != nil {
		return "", err
	}
	return string(jsonBuf), err
}

// callAPI do the request.
func (c *APIClient) callAPI(request *http.Request) (*http.Response, error) {

	if c.AuthClient == nil {
		return nil, errors.New("invalid or missing client configuration")
	}

	var httpClient *http.Client
	var err error

	httpClient, err = c.AuthClient.GetHttpClient()

	//if c.AuthClient. {
	//	dump, err := httputil.DumpRequestOut(request, true)
	//	if err != nil {
	//		return nil, err
	//	}
	//	log.Printf("\n%s\n", string(dump))
	//}

	resp, err := httpClient.Do(request)
	if err != nil {
		return resp, err
	}

	//if c.AuthClient.Debug {
	//	dump, err := httputil.DumpResponse(resp, true)
	//	if err != nil {
	//		return resp, err
	//	}
	//	log.Printf("\n%s\n", string(dump))
	//}
	return resp, err
}

// Allow modification of underlying config for alternate implementations and testing
// Caution: modifying the configuration while live can cause data races and potentially unwanted behavior
func (c *APIClient) GetConfig() *auth_providers.Server {
	if c.AuthClient == nil {
		return nil
	}
	return c.AuthClient.GetServerConfig()

}

type formFile struct {
	fileBytes    []byte
	fileName     string
	formFileName string
}

// prepareRequest build the request
func (c *APIClient) prepareRequest(
	ctx context.Context,
	path string, method string,
	postBody interface{},
	headerParams map[string]string,
	queryParams url.Values,
	formParams url.Values,
	formFiles []formFile,
) (localVarRequest *http.Request, err error) {

	var body *bytes.Buffer

	// Detect postBody type and post.
	if postBody != nil {
		contentType := headerParams["Content-Type"]
		if contentType == "" {
			contentType = detectContentType(postBody)
			headerParams["Content-Type"] = contentType
		}

		body, err = setBody(postBody, contentType)
		if err != nil {
			return nil, err
		}
	}

	// add form parameters and file if available.
	if strings.HasPrefix(
		headerParams["Content-Type"],
		"multipart/form-data",
	) && len(formParams) > 0 || (len(formFiles) > 0) {
		if body != nil {
			return nil, errors.New("Cannot specify postBody and multipart form at the same time.")
		}
		body = &bytes.Buffer{}
		w := multipart.NewWriter(body)

		for k, v := range formParams {
			for _, iv := range v {
				if strings.HasPrefix(k, "@") { // file
					err = addFile(w, k[1:], iv)
					if err != nil {
						return nil, err
					}
				} else { // form value
					w.WriteField(k, iv)
				}
			}
		}
		for _, formFile := range formFiles {
			if len(formFile.fileBytes) > 0 && formFile.fileName != "" {
				w.Boundary()
				part, err := w.CreateFormFile(formFile.formFileName, filepath.Base(formFile.fileName))
				if err != nil {
					return nil, err
				}
				_, err = part.Write(formFile.fileBytes)
				if err != nil {
					return nil, err
				}
			}
		}

		// Set the Boundary in the Content-Type
		headerParams["Content-Type"] = w.FormDataContentType()

		// Set Content-Length
		headerParams["Content-Length"] = fmt.Sprintf("%d", body.Len())
		w.Close()
	}

	if strings.HasPrefix(headerParams["Content-Type"], "application/x-www-form-urlencoded") && len(formParams) > 0 {
		if body != nil {
			return nil, errors.New("Cannot specify postBody and x-www-form-urlencoded form at the same time.")
		}
		body = &bytes.Buffer{}
		body.WriteString(formParams.Encode())
		// Set Content-Length
		headerParams["Content-Length"] = fmt.Sprintf("%d", body.Len())
	}

	// Setup path and query parameters
	url, err := url.Parse(path)
	if err != nil {
		return nil, err
	}

	// Override request host, if applicable
	serverConfig := c.GetConfig()
	if serverConfig.Host != "" {
		if serverConfig.Port > 0 && serverConfig.Port <= 65535 {
			url.Host = fmt.Sprintf("%s:%d", serverConfig.Host, serverConfig.Port)
		} else {
			url.Host = serverConfig.Host
		}
	}

	// Override request scheme
	url.Scheme = "https"

	// Adding Query Param
	query := url.Query()
	for k, v := range queryParams {
		for _, iv := range v {
			query.Add(k, iv)
		}
	}

	// Encode the parameters.
	url.RawQuery = queryParamSplit.ReplaceAllStringFunc(
		query.Encode(), func(s string) string {
			pieces := strings.Split(s, "=")
			pieces[0] = queryDescape.Replace(pieces[0])
			return strings.Join(pieces, "=")
		},
	)

	// Generate a new request
	if body != nil {
		localVarRequest, err = http.NewRequest(method, url.String(), body)
	} else {
		localVarRequest, err = http.NewRequest(method, url.String(), nil)
	}
	if err != nil {
		return nil, err
	}

	// add header parameters, if any
	if len(headerParams) > 0 {
		headers := http.Header{}
		for h, v := range headerParams {
			headers[h] = []string{v}
		}
		localVarRequest.Header = headers
	}

	// Add the user agent to the request.
	//localVarRequest.Header.Add("User-Agent", c.AuthClient.U)
	localVarRequest.Header.Add("User-Agent", "OpenAPI-Generator/1.0.0/go")
	if ctx != nil {
		// add context to the request
		localVarRequest = localVarRequest.WithContext(ctx)

	}

	//localVarRequest.SetBasicAuth(c.AuthClient.BasicAuth.UserName, c.AuthClient.BasicAuth.Password)
	//
	//for header, value := range c.AuthClient.DefaultHeader {
	//	localVarRequest.Header.Add(header, value)
	//}
	return localVarRequest, nil
}

func (c *APIClient) decode(v interface{}, b []byte, contentType string) (err error) {
	if len(b) == 0 {
		return nil
	}
	if s, ok := v.(*string); ok {
		*s = string(b)
		return nil
	}
	if f, ok := v.(*os.File); ok {
		f, err = ioutil.TempFile("", "HttpClientFile")
		if err != nil {
			return
		}
		_, err = f.Write(b)
		if err != nil {
			return
		}
		_, err = f.Seek(0, io.SeekStart)
		return
	}
	if f, ok := v.(**os.File); ok {
		*f, err = ioutil.TempFile("", "HttpClientFile")
		if err != nil {
			return
		}
		_, err = (*f).Write(b)
		if err != nil {
			return
		}
		_, err = (*f).Seek(0, io.SeekStart)
		return
	}
	if xmlCheck.MatchString(contentType) {
		if err = xml.Unmarshal(b, v); err != nil {
			return err
		}
		return nil
	}
	if jsonCheck.MatchString(contentType) {
		if actualObj, ok := v.(interface{ GetActualInstance() interface{} }); ok { // oneOf, anyOf schemas
			if unmarshalObj, ok := actualObj.(interface{ UnmarshalJSON([]byte) error }); ok { // make sure it has UnmarshalJSON defined
				if err = unmarshalObj.UnmarshalJSON(b); err != nil {
					return err
				}
			} else {
				return errors.New("Unknown type with GetActualInstance but no unmarshalObj.UnmarshalJSON defined")
			}
		} else if err = json.Unmarshal(b, v); err != nil { // simple model
			return err
		}
		return nil
	}
	return errors.New("undefined response type")
}

// Add a file to the multipart request
func addFile(w *multipart.Writer, fieldName, path string) error {
	file, err := os.Open(filepath.Clean(path))
	if err != nil {
		return err
	}
	err = file.Close()
	if err != nil {
		return err
	}

	part, err := w.CreateFormFile(fieldName, filepath.Base(path))
	if err != nil {
		return err
	}
	_, err = io.Copy(part, file)

	return err
}

// Prevent trying to import "fmt"
func reportError(format string, a ...interface{}) error {
	return fmt.Errorf(format, a...)
}

// A wrapper for strict JSON decoding
func newStrictDecoder(data []byte) *json.Decoder {
	dec := json.NewDecoder(bytes.NewBuffer(data))
	dec.DisallowUnknownFields()
	return dec
}

// Set request body from an interface{}
func setBody(body interface{}, contentType string) (bodyBuf *bytes.Buffer, err error) {
	if bodyBuf == nil {
		bodyBuf = &bytes.Buffer{}
	}

	if reader, ok := body.(io.Reader); ok {
		_, err = bodyBuf.ReadFrom(reader)
	} else if fp, ok := body.(*os.File); ok {
		_, err = bodyBuf.ReadFrom(fp)
	} else if b, ok := body.([]byte); ok {
		_, err = bodyBuf.Write(b)
	} else if s, ok := body.(string); ok {
		_, err = bodyBuf.WriteString(s)
	} else if s, ok := body.(*string); ok {
		_, err = bodyBuf.WriteString(*s)
	} else if jsonCheck.MatchString(contentType) {
		err = json.NewEncoder(bodyBuf).Encode(body)
	} else if xmlCheck.MatchString(contentType) {
		err = xml.NewEncoder(bodyBuf).Encode(body)
	}

	if err != nil {
		return nil, err
	}

	if bodyBuf.Len() == 0 {
		err = fmt.Errorf("invalid body type %s\n", contentType)
		return nil, err
	}
	return bodyBuf, nil
}

// detectContentType method is used to figure out `Request.Body` content type for request header
func detectContentType(body interface{}) string {
	contentType := "text/plain; charset=utf-8"
	kind := reflect.TypeOf(body).Kind()

	switch kind {
	case reflect.Struct, reflect.Map, reflect.Ptr:
		contentType = "application/json; charset=utf-8"
	case reflect.String:
		contentType = "text/plain; charset=utf-8"
	default:
		if b, ok := body.([]byte); ok {
			contentType = http.DetectContentType(b)
		} else if kind == reflect.Slice {
			contentType = "application/json; charset=utf-8"
		}
	}

	return contentType
}

// Ripped from https://github.com/gregjones/httpcache/blob/master/httpcache.go
type cacheControl map[string]string

func parseCacheControl(headers http.Header) cacheControl {
	cc := cacheControl{}
	ccHeader := headers.Get("Cache-Control")
	for _, part := range strings.Split(ccHeader, ",") {
		part = strings.Trim(part, " ")
		if part == "" {
			continue
		}
		if strings.ContainsRune(part, '=') {
			keyval := strings.Split(part, "=")
			cc[strings.Trim(keyval[0], " ")] = strings.Trim(keyval[1], ",")
		} else {
			cc[part] = ""
		}
	}
	return cc
}

// CacheExpires helper function to determine remaining time before repeating a request.
func CacheExpires(r *http.Response) time.Time {
	// Figure out when the cache expires.
	var expires time.Time
	now, err := time.Parse(time.RFC1123, r.Header.Get("date"))
	if err != nil {
		return time.Now()
	}
	respCacheControl := parseCacheControl(r.Header)

	if maxAge, ok := respCacheControl["max-age"]; ok {
		lifetime, err := time.ParseDuration(maxAge + "s")
		if err != nil {
			expires = now
		} else {
			expires = now.Add(lifetime)
		}
	} else {
		expiresHeader := r.Header.Get("Expires")
		if expiresHeader != "" {
			expires, err = time.Parse(time.RFC1123, expiresHeader)
			if err != nil {
				expires = now
			}
		}
	}
	return expires
}

func strlen(s string) int {
	return utf8.RuneCountInString(s)
}

// GenericOpenAPIError Provides access to the body, error and model on returned errors.
type GenericOpenAPIError struct {
	body  []byte
	error string
	model interface{}
}

// Error returns non-empty string if there was an error.
func (e GenericOpenAPIError) Error() string {
	return e.error
}

// Body returns the raw bytes of the response
func (e GenericOpenAPIError) Body() []byte {
	return e.body
}

// Model returns the unpacked model of the error
func (e GenericOpenAPIError) Model() interface{} {
	return e.model
}

// format error message using title and detail when model implements rfc7807
func formatErrorMessage(status string, v interface{}) string {
	str := ""
	metaValue := reflect.ValueOf(v).Elem()

	field := metaValue.FieldByName("Title")
	if field != (reflect.Value{}) {
		str = fmt.Sprintf("%s", field.Interface())
	}

	field = metaValue.FieldByName("Detail")
	if field != (reflect.Value{}) {
		str = fmt.Sprintf("%s (%s)", str, field.Interface())
	}

	// status title (detail)
	return strings.TrimSpace(fmt.Sprintf("%s %s", status, str))
}
