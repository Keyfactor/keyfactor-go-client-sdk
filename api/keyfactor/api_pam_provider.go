/*
Copyright 2022 Keyfactor
Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License.  You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0.  Unless
required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
OR CONDITIONS OF ANY KIND, either express or implied. See the License for
thespecific language governing permissions and limitations under the
License.
Keyfactor-v1

This reference serves to document REST-based methods to manage and integrate with Keyfactor. In addition, an embedded interface allows for the execution of calls against the current Keyfactor API instance.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package keyfactor

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// PAMProviderApiService PAMProviderApi service
type PAMProviderApiService service

type ApiPAMProviderCreatePamProviderRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	xKeyfactorRequestedWith *string
	provider                *CSSCMSDataModelModelsProvider
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPAMProviderCreatePamProviderRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPAMProviderCreatePamProviderRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// PAM provider properties to be used
func (r ApiPAMProviderCreatePamProviderRequest) Provider(provider CSSCMSDataModelModelsProvider) ApiPAMProviderCreatePamProviderRequest {
	r.provider = &provider
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPAMProviderCreatePamProviderRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPAMProviderCreatePamProviderRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiPAMProviderCreatePamProviderRequest) Execute() (*CSSCMSDataModelModelsProvider, *http.Response, error) {
	return r.ApiService.PAMProviderCreatePamProviderExecute(r)
}

/*
PAMProviderCreatePamProvider Creates a new PAM provider with the associated properties

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPAMProviderCreatePamProviderRequest
*/
func (a *PAMProviderApiService) PAMProviderCreatePamProvider(ctx context.Context) ApiPAMProviderCreatePamProviderRequest {
	requestedWith := "APIClient"
	version := "1"
	return ApiPAMProviderCreatePamProviderRequest{
		ApiService:              a,
		ctx:                     ctx,
		xKeyfactorRequestedWith: &requestedWith,
		xKeyfactorApiVersion:    &version,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsProvider
func (a *PAMProviderApiService) PAMProviderCreatePamProviderExecute(r ApiPAMProviderCreatePamProviderRequest) (*CSSCMSDataModelModelsProvider, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsProvider
	)

	localBasePath := "/KeyfactorAPI"

	localVarPath := localBasePath + "/PamProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.provider == nil {
		return localVarReturnValue, nil, reportError("provider is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.provider
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPAMProviderCreatePamProviderTypeRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	xKeyfactorRequestedWith *string
	type_                   *KeyfactorApiPAMProviderTypeCreateRequest
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPAMProviderCreatePamProviderTypeRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPAMProviderCreatePamProviderTypeRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// PAM provider type properties to be used
func (r ApiPAMProviderCreatePamProviderTypeRequest) Type_(type_ KeyfactorApiPAMProviderTypeCreateRequest) ApiPAMProviderCreatePamProviderTypeRequest {
	r.type_ = &type_
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPAMProviderCreatePamProviderTypeRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPAMProviderCreatePamProviderTypeRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiPAMProviderCreatePamProviderTypeRequest) Execute() (*KeyfactorApiPAMProviderTypeResponse, *http.Response, error) {
	return r.ApiService.PAMProviderCreatePamProviderTypeExecute(r)
}

/*
PAMProviderCreatePamProviderType Creates a new PAM provider type with the associated properties

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPAMProviderCreatePamProviderTypeRequest
*/
func (a *PAMProviderApiService) PAMProviderCreatePamProviderType(ctx context.Context) ApiPAMProviderCreatePamProviderTypeRequest {
	requestedWith := "APIClient"
	version := "1"
	return ApiPAMProviderCreatePamProviderTypeRequest{
		ApiService:              a,
		ctx:                     ctx,
		xKeyfactorRequestedWith: &requestedWith,
		xKeyfactorApiVersion:    &version,
	}
}

// Execute executes the request
//
//	@return KeyfactorApiPAMProviderTypeResponse
func (a *PAMProviderApiService) PAMProviderCreatePamProviderTypeExecute(r ApiPAMProviderCreatePamProviderTypeRequest) (*KeyfactorApiPAMProviderTypeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *KeyfactorApiPAMProviderTypeResponse
	)

	localBasePath := "/KeyfactorAPI"

	localVarPath := localBasePath + "/PamProviders/Types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.type_
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPAMProviderDeletePamProviderRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPAMProviderDeletePamProviderRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPAMProviderDeletePamProviderRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPAMProviderDeletePamProviderRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPAMProviderDeletePamProviderRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiPAMProviderDeletePamProviderRequest) Execute() (*http.Response, error) {
	return r.ApiService.PAMProviderDeletePamProviderExecute(r)
}

/*
PAMProviderDeletePamProvider Deletes a PAM Provider

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor identifier of the PAM provider to be deleted
	@return ApiPAMProviderDeletePamProviderRequest
*/
func (a *PAMProviderApiService) PAMProviderDeletePamProvider(ctx context.Context, id int32) ApiPAMProviderDeletePamProviderRequest {
	requestedWith := "APIClient"
	version := "1"
	return ApiPAMProviderDeletePamProviderRequest{
		ApiService:              a,
		ctx:                     ctx,
		xKeyfactorRequestedWith: &requestedWith,
		xKeyfactorApiVersion:    &version,
		id:                      id,
	}
}

// Execute executes the request
func (a *PAMProviderApiService) PAMProviderDeletePamProviderExecute(r ApiPAMProviderDeletePamProviderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath := "/KeyfactorAPI"

	localVarPath := localBasePath + "/PamProviders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPAMProviderGetPamProviderRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	id                      int32
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPAMProviderGetPamProviderRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPAMProviderGetPamProviderRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPAMProviderGetPamProviderRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPAMProviderGetPamProviderRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiPAMProviderGetPamProviderRequest) Execute() (*CSSCMSDataModelModelsProvider, *http.Response, error) {
	return r.ApiService.PAMProviderGetPamProviderExecute(r)
}

/*
PAMProviderGetPamProvider Returns a single PAM Provider that matches the associated id

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Keyfactor identifier of the PAM provider
	@return ApiPAMProviderGetPamProviderRequest
*/
func (a *PAMProviderApiService) PAMProviderGetPamProvider(ctx context.Context, id int32) ApiPAMProviderGetPamProviderRequest {
	requestedWith := "APIClient"
	version := "1"
	return ApiPAMProviderGetPamProviderRequest{
		ApiService:              a,
		ctx:                     ctx,
		xKeyfactorRequestedWith: &requestedWith,
		xKeyfactorApiVersion:    &version,
		id:                      id,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsProvider
func (a *PAMProviderApiService) PAMProviderGetPamProviderExecute(r ApiPAMProviderGetPamProviderRequest) (*CSSCMSDataModelModelsProvider, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsProvider
	)

	localBasePath := "/KeyfactorAPI"

	localVarPath := localBasePath + "/PamProviders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPAMProviderGetPamProviderTypesRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPAMProviderGetPamProviderTypesRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPAMProviderGetPamProviderTypesRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPAMProviderGetPamProviderTypesRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPAMProviderGetPamProviderTypesRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiPAMProviderGetPamProviderTypesRequest) Execute() ([]CSSCMSDataModelModelsProviderType, *http.Response, error) {
	return r.ApiService.PAMProviderGetPamProviderTypesExecute(r)
}

/*
PAMProviderGetPamProviderTypes Returns all PAM providers in the Keyfactor instance

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPAMProviderGetPamProviderTypesRequest
*/
func (a *PAMProviderApiService) PAMProviderGetPamProviderTypes(ctx context.Context) ApiPAMProviderGetPamProviderTypesRequest {
	requestedWith := "APIClient"
	version := "1"
	return ApiPAMProviderGetPamProviderTypesRequest{
		ApiService:              a,
		ctx:                     ctx,
		xKeyfactorRequestedWith: &requestedWith,
		xKeyfactorApiVersion:    &version,
	}
}

// Execute executes the request
//
//	@return []CSSCMSDataModelModelsProviderType
func (a *PAMProviderApiService) PAMProviderGetPamProviderTypesExecute(r ApiPAMProviderGetPamProviderTypesRequest) ([]CSSCMSDataModelModelsProviderType, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CSSCMSDataModelModelsProviderType
	)

	localBasePath := "/KeyfactorAPI"

	localVarPath := localBasePath + "/PamProviders/Types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPAMProviderGetPamProvidersRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	xKeyfactorRequestedWith *string
	xKeyfactorApiVersion    *string
	pqQueryString           *string
	pqPageReturned          *int32
	pqReturnLimit           *int32
	pqSortField             *string
	pqSortAscending         *int32
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPAMProviderGetPamProvidersRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPAMProviderGetPamProvidersRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPAMProviderGetPamProvidersRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPAMProviderGetPamProvidersRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

// Contents of the query (ex: field1 -eq value1 AND field2 -gt value2)
func (r ApiPAMProviderGetPamProvidersRequest) PqQueryString(pqQueryString string) ApiPAMProviderGetPamProvidersRequest {
	r.pqQueryString = &pqQueryString
	return r
}

// The current page within the result set to be returned
func (r ApiPAMProviderGetPamProvidersRequest) PqPageReturned(pqPageReturned int32) ApiPAMProviderGetPamProvidersRequest {
	r.pqPageReturned = &pqPageReturned
	return r
}

// Maximum number of records to be returned in a single call
func (r ApiPAMProviderGetPamProvidersRequest) PqReturnLimit(pqReturnLimit int32) ApiPAMProviderGetPamProvidersRequest {
	r.pqReturnLimit = &pqReturnLimit
	return r
}

// Field by which the results should be sorted (view results via Management Portal for sortable columns)
func (r ApiPAMProviderGetPamProvidersRequest) PqSortField(pqSortField string) ApiPAMProviderGetPamProvidersRequest {
	r.pqSortField = &pqSortField
	return r
}

// Field sort direction [0&#x3D;ascending, 1&#x3D;descending]
func (r ApiPAMProviderGetPamProvidersRequest) PqSortAscending(pqSortAscending int32) ApiPAMProviderGetPamProvidersRequest {
	r.pqSortAscending = &pqSortAscending
	return r
}

func (r ApiPAMProviderGetPamProvidersRequest) Execute() ([]CSSCMSDataModelModelsProvider, *http.Response, error) {
	return r.ApiService.PAMProviderGetPamProvidersExecute(r)
}

/*
PAMProviderGetPamProviders Returns all PAM providers according to the provided filter and output parameters

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPAMProviderGetPamProvidersRequest
*/
func (a *PAMProviderApiService) PAMProviderGetPamProviders(ctx context.Context) ApiPAMProviderGetPamProvidersRequest {
	requestedWith := "APIClient"
	version := "1"
	return ApiPAMProviderGetPamProvidersRequest{
		ApiService:              a,
		ctx:                     ctx,
		xKeyfactorRequestedWith: &requestedWith,
		xKeyfactorApiVersion:    &version,
	}
}

// Execute executes the request
//
//	@return []CSSCMSDataModelModelsProvider
func (a *PAMProviderApiService) PAMProviderGetPamProvidersExecute(r ApiPAMProviderGetPamProvidersRequest) ([]CSSCMSDataModelModelsProvider, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []CSSCMSDataModelModelsProvider
	)

	localBasePath := "/KeyfactorAPI"

	localVarPath := localBasePath + "/PamProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}

	if r.pqQueryString != nil {
		parameterAddToQuery(localVarQueryParams, "pq.queryString", r.pqQueryString, "")
	}
	if r.pqPageReturned != nil {
		parameterAddToQuery(localVarQueryParams, "pq.pageReturned", r.pqPageReturned, "")
	}
	if r.pqReturnLimit != nil {
		parameterAddToQuery(localVarQueryParams, "pq.returnLimit", r.pqReturnLimit, "")
	}
	if r.pqSortField != nil {
		parameterAddToQuery(localVarQueryParams, "pq.sortField", r.pqSortField, "")
	}
	if r.pqSortAscending != nil {
		parameterAddToQuery(localVarQueryParams, "pq.sortAscending", r.pqSortAscending, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPAMProviderUpdatePamProviderRequest struct {
	ctx                     context.Context
	ApiService              *PAMProviderApiService
	xKeyfactorRequestedWith *string
	provider                *CSSCMSDataModelModelsProvider
	xKeyfactorApiVersion    *string
}

// Type of the request [XMLHttpRequest, APIClient]
func (r ApiPAMProviderUpdatePamProviderRequest) XKeyfactorRequestedWith(xKeyfactorRequestedWith string) ApiPAMProviderUpdatePamProviderRequest {
	r.xKeyfactorRequestedWith = &xKeyfactorRequestedWith
	return r
}

// PAM provider properties to be used
func (r ApiPAMProviderUpdatePamProviderRequest) Provider(provider CSSCMSDataModelModelsProvider) ApiPAMProviderUpdatePamProviderRequest {
	r.provider = &provider
	return r
}

// Desired version of the api, if not provided defaults to v1
func (r ApiPAMProviderUpdatePamProviderRequest) XKeyfactorApiVersion(xKeyfactorApiVersion string) ApiPAMProviderUpdatePamProviderRequest {
	r.xKeyfactorApiVersion = &xKeyfactorApiVersion
	return r
}

func (r ApiPAMProviderUpdatePamProviderRequest) Execute() (*CSSCMSDataModelModelsProvider, *http.Response, error) {
	return r.ApiService.PAMProviderUpdatePamProviderExecute(r)
}

/*
PAMProviderUpdatePamProvider Updates an existing PAM provider according to the provided properties

### PAM Provider Data Types ###
| Value              | Description               |
|--------------------|---------------------------|
| 1                  | string                    |
| 2                  | secret                    |

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPAMProviderUpdatePamProviderRequest
*/
func (a *PAMProviderApiService) PAMProviderUpdatePamProvider(ctx context.Context) ApiPAMProviderUpdatePamProviderRequest {
	requestedWith := "APIClient"
	version := "1"
	return ApiPAMProviderUpdatePamProviderRequest{
		ApiService:              a,
		ctx:                     ctx,
		xKeyfactorRequestedWith: &requestedWith,
		xKeyfactorApiVersion:    &version,
	}
}

// Execute executes the request
//
//	@return CSSCMSDataModelModelsProvider
func (a *PAMProviderApiService) PAMProviderUpdatePamProviderExecute(r ApiPAMProviderUpdatePamProviderRequest) (*CSSCMSDataModelModelsProvider, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CSSCMSDataModelModelsProvider
	)

	localBasePath := "/KeyfactorAPI"

	localVarPath := localBasePath + "/PamProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xKeyfactorRequestedWith == nil {
		return localVarReturnValue, nil, reportError("xKeyfactorRequestedWith is required and must be specified")
	}
	if r.provider == nil {
		return localVarReturnValue, nil, reportError("provider is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/xml", "text/xml", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/json", "application/xml", "text/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xKeyfactorApiVersion != nil {
		parameterAddToQuery(localVarHeaderParams, "x-keyfactor-api-version", r.xKeyfactorApiVersion, "")
	}
	parameterAddToQuery(localVarHeaderParams, "x-keyfactor-requested-with", r.xKeyfactorRequestedWith, "")
	// body params
	localVarPostBody = r.provider
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
